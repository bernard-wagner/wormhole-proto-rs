// This file is generated by rust-protobuf 2.18.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `gossip/v1/gossip.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_2;

#[derive(PartialEq,Clone,Default)]
pub struct GossipMessage {
    // message oneof groups
    pub message: ::std::option::Option<GossipMessage_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GossipMessage {
    fn default() -> &'a GossipMessage {
        <GossipMessage as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum GossipMessage_oneof_message {
    signed_observation(SignedObservation),
    signed_heartbeat(SignedHeartbeat),
    signed_vaa_with_quorum(SignedVAAWithQuorum),
    signed_observation_request(SignedObservationRequest),
    signed_batch_observation(SignedBatchObservation),
    signed_batch_vaa_with_quorum(SignedBatchVAAWithQuorum),
    signed_chain_governor_config(SignedChainGovernorConfig),
    signed_chain_governor_status(SignedChainGovernorStatus),
}

impl GossipMessage {
    pub fn new() -> GossipMessage {
        ::std::default::Default::default()
    }

    // .gossip.v1.SignedObservation signed_observation = 2;


    pub fn get_signed_observation(&self) -> &SignedObservation {
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_observation(ref v)) => v,
            _ => <SignedObservation as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_signed_observation(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_signed_observation(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_observation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_observation(&mut self, v: SignedObservation) {
        self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_observation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_observation(&mut self) -> &mut SignedObservation {
        if let ::std::option::Option::Some(GossipMessage_oneof_message::signed_observation(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_observation(SignedObservation::new()));
        }
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_observation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_observation(&mut self) -> SignedObservation {
        if self.has_signed_observation() {
            match self.message.take() {
                ::std::option::Option::Some(GossipMessage_oneof_message::signed_observation(v)) => v,
                _ => panic!(),
            }
        } else {
            SignedObservation::new()
        }
    }

    // .gossip.v1.SignedHeartbeat signed_heartbeat = 3;


    pub fn get_signed_heartbeat(&self) -> &SignedHeartbeat {
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_heartbeat(ref v)) => v,
            _ => <SignedHeartbeat as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_signed_heartbeat(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_signed_heartbeat(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_heartbeat(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_heartbeat(&mut self, v: SignedHeartbeat) {
        self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_heartbeat(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_heartbeat(&mut self) -> &mut SignedHeartbeat {
        if let ::std::option::Option::Some(GossipMessage_oneof_message::signed_heartbeat(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_heartbeat(SignedHeartbeat::new()));
        }
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_heartbeat(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_heartbeat(&mut self) -> SignedHeartbeat {
        if self.has_signed_heartbeat() {
            match self.message.take() {
                ::std::option::Option::Some(GossipMessage_oneof_message::signed_heartbeat(v)) => v,
                _ => panic!(),
            }
        } else {
            SignedHeartbeat::new()
        }
    }

    // .gossip.v1.SignedVAAWithQuorum signed_vaa_with_quorum = 4;


    pub fn get_signed_vaa_with_quorum(&self) -> &SignedVAAWithQuorum {
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_vaa_with_quorum(ref v)) => v,
            _ => <SignedVAAWithQuorum as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_signed_vaa_with_quorum(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_signed_vaa_with_quorum(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_vaa_with_quorum(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_vaa_with_quorum(&mut self, v: SignedVAAWithQuorum) {
        self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_vaa_with_quorum(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_vaa_with_quorum(&mut self) -> &mut SignedVAAWithQuorum {
        if let ::std::option::Option::Some(GossipMessage_oneof_message::signed_vaa_with_quorum(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_vaa_with_quorum(SignedVAAWithQuorum::new()));
        }
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_vaa_with_quorum(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_vaa_with_quorum(&mut self) -> SignedVAAWithQuorum {
        if self.has_signed_vaa_with_quorum() {
            match self.message.take() {
                ::std::option::Option::Some(GossipMessage_oneof_message::signed_vaa_with_quorum(v)) => v,
                _ => panic!(),
            }
        } else {
            SignedVAAWithQuorum::new()
        }
    }

    // .gossip.v1.SignedObservationRequest signed_observation_request = 5;


    pub fn get_signed_observation_request(&self) -> &SignedObservationRequest {
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_observation_request(ref v)) => v,
            _ => <SignedObservationRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_signed_observation_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_signed_observation_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_observation_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_observation_request(&mut self, v: SignedObservationRequest) {
        self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_observation_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_observation_request(&mut self) -> &mut SignedObservationRequest {
        if let ::std::option::Option::Some(GossipMessage_oneof_message::signed_observation_request(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_observation_request(SignedObservationRequest::new()));
        }
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_observation_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_observation_request(&mut self) -> SignedObservationRequest {
        if self.has_signed_observation_request() {
            match self.message.take() {
                ::std::option::Option::Some(GossipMessage_oneof_message::signed_observation_request(v)) => v,
                _ => panic!(),
            }
        } else {
            SignedObservationRequest::new()
        }
    }

    // .gossip.v1.SignedBatchObservation signed_batch_observation = 6;


    pub fn get_signed_batch_observation(&self) -> &SignedBatchObservation {
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_batch_observation(ref v)) => v,
            _ => <SignedBatchObservation as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_signed_batch_observation(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_signed_batch_observation(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_batch_observation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_batch_observation(&mut self, v: SignedBatchObservation) {
        self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_batch_observation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_batch_observation(&mut self) -> &mut SignedBatchObservation {
        if let ::std::option::Option::Some(GossipMessage_oneof_message::signed_batch_observation(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_batch_observation(SignedBatchObservation::new()));
        }
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_batch_observation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_batch_observation(&mut self) -> SignedBatchObservation {
        if self.has_signed_batch_observation() {
            match self.message.take() {
                ::std::option::Option::Some(GossipMessage_oneof_message::signed_batch_observation(v)) => v,
                _ => panic!(),
            }
        } else {
            SignedBatchObservation::new()
        }
    }

    // .gossip.v1.SignedBatchVAAWithQuorum signed_batch_vaa_with_quorum = 7;


    pub fn get_signed_batch_vaa_with_quorum(&self) -> &SignedBatchVAAWithQuorum {
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_batch_vaa_with_quorum(ref v)) => v,
            _ => <SignedBatchVAAWithQuorum as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_signed_batch_vaa_with_quorum(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_signed_batch_vaa_with_quorum(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_batch_vaa_with_quorum(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_batch_vaa_with_quorum(&mut self, v: SignedBatchVAAWithQuorum) {
        self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_batch_vaa_with_quorum(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_batch_vaa_with_quorum(&mut self) -> &mut SignedBatchVAAWithQuorum {
        if let ::std::option::Option::Some(GossipMessage_oneof_message::signed_batch_vaa_with_quorum(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_batch_vaa_with_quorum(SignedBatchVAAWithQuorum::new()));
        }
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_batch_vaa_with_quorum(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_batch_vaa_with_quorum(&mut self) -> SignedBatchVAAWithQuorum {
        if self.has_signed_batch_vaa_with_quorum() {
            match self.message.take() {
                ::std::option::Option::Some(GossipMessage_oneof_message::signed_batch_vaa_with_quorum(v)) => v,
                _ => panic!(),
            }
        } else {
            SignedBatchVAAWithQuorum::new()
        }
    }

    // .gossip.v1.SignedChainGovernorConfig signed_chain_governor_config = 8;


    pub fn get_signed_chain_governor_config(&self) -> &SignedChainGovernorConfig {
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_chain_governor_config(ref v)) => v,
            _ => <SignedChainGovernorConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_signed_chain_governor_config(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_signed_chain_governor_config(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_chain_governor_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_chain_governor_config(&mut self, v: SignedChainGovernorConfig) {
        self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_chain_governor_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_chain_governor_config(&mut self) -> &mut SignedChainGovernorConfig {
        if let ::std::option::Option::Some(GossipMessage_oneof_message::signed_chain_governor_config(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_chain_governor_config(SignedChainGovernorConfig::new()));
        }
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_chain_governor_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_chain_governor_config(&mut self) -> SignedChainGovernorConfig {
        if self.has_signed_chain_governor_config() {
            match self.message.take() {
                ::std::option::Option::Some(GossipMessage_oneof_message::signed_chain_governor_config(v)) => v,
                _ => panic!(),
            }
        } else {
            SignedChainGovernorConfig::new()
        }
    }

    // .gossip.v1.SignedChainGovernorStatus signed_chain_governor_status = 9;


    pub fn get_signed_chain_governor_status(&self) -> &SignedChainGovernorStatus {
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_chain_governor_status(ref v)) => v,
            _ => <SignedChainGovernorStatus as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_signed_chain_governor_status(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_signed_chain_governor_status(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_chain_governor_status(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_chain_governor_status(&mut self, v: SignedChainGovernorStatus) {
        self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_chain_governor_status(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_chain_governor_status(&mut self) -> &mut SignedChainGovernorStatus {
        if let ::std::option::Option::Some(GossipMessage_oneof_message::signed_chain_governor_status(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_chain_governor_status(SignedChainGovernorStatus::new()));
        }
        match self.message {
            ::std::option::Option::Some(GossipMessage_oneof_message::signed_chain_governor_status(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_chain_governor_status(&mut self) -> SignedChainGovernorStatus {
        if self.has_signed_chain_governor_status() {
            match self.message.take() {
                ::std::option::Option::Some(GossipMessage_oneof_message::signed_chain_governor_status(v)) => v,
                _ => panic!(),
            }
        } else {
            SignedChainGovernorStatus::new()
        }
    }
}

impl ::protobuf::Message for GossipMessage {
    fn is_initialized(&self) -> bool {
        if let Some(GossipMessage_oneof_message::signed_observation(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GossipMessage_oneof_message::signed_heartbeat(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GossipMessage_oneof_message::signed_vaa_with_quorum(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GossipMessage_oneof_message::signed_observation_request(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GossipMessage_oneof_message::signed_batch_observation(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GossipMessage_oneof_message::signed_batch_vaa_with_quorum(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GossipMessage_oneof_message::signed_chain_governor_config(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GossipMessage_oneof_message::signed_chain_governor_status(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_observation(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_heartbeat(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_vaa_with_quorum(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_observation_request(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_batch_observation(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_batch_vaa_with_quorum(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_chain_governor_config(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(GossipMessage_oneof_message::signed_chain_governor_status(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &GossipMessage_oneof_message::signed_observation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GossipMessage_oneof_message::signed_heartbeat(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GossipMessage_oneof_message::signed_vaa_with_quorum(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GossipMessage_oneof_message::signed_observation_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GossipMessage_oneof_message::signed_batch_observation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GossipMessage_oneof_message::signed_batch_vaa_with_quorum(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GossipMessage_oneof_message::signed_chain_governor_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GossipMessage_oneof_message::signed_chain_governor_status(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &GossipMessage_oneof_message::signed_observation(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GossipMessage_oneof_message::signed_heartbeat(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GossipMessage_oneof_message::signed_vaa_with_quorum(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GossipMessage_oneof_message::signed_observation_request(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GossipMessage_oneof_message::signed_batch_observation(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GossipMessage_oneof_message::signed_batch_vaa_with_quorum(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GossipMessage_oneof_message::signed_chain_governor_config(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GossipMessage_oneof_message::signed_chain_governor_status(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GossipMessage {
        GossipMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SignedObservation>(
                "signed_observation",
                GossipMessage::has_signed_observation,
                GossipMessage::get_signed_observation,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SignedHeartbeat>(
                "signed_heartbeat",
                GossipMessage::has_signed_heartbeat,
                GossipMessage::get_signed_heartbeat,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SignedVAAWithQuorum>(
                "signed_vaa_with_quorum",
                GossipMessage::has_signed_vaa_with_quorum,
                GossipMessage::get_signed_vaa_with_quorum,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SignedObservationRequest>(
                "signed_observation_request",
                GossipMessage::has_signed_observation_request,
                GossipMessage::get_signed_observation_request,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SignedBatchObservation>(
                "signed_batch_observation",
                GossipMessage::has_signed_batch_observation,
                GossipMessage::get_signed_batch_observation,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SignedBatchVAAWithQuorum>(
                "signed_batch_vaa_with_quorum",
                GossipMessage::has_signed_batch_vaa_with_quorum,
                GossipMessage::get_signed_batch_vaa_with_quorum,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SignedChainGovernorConfig>(
                "signed_chain_governor_config",
                GossipMessage::has_signed_chain_governor_config,
                GossipMessage::get_signed_chain_governor_config,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SignedChainGovernorStatus>(
                "signed_chain_governor_status",
                GossipMessage::has_signed_chain_governor_status,
                GossipMessage::get_signed_chain_governor_status,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GossipMessage>(
                "GossipMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GossipMessage {
        static instance: ::protobuf::rt::LazyV2<GossipMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GossipMessage::new)
    }
}

impl ::protobuf::Clear for GossipMessage {
    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GossipMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GossipMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignedHeartbeat {
    // message fields
    pub heartbeat: ::std::vec::Vec<u8>,
    pub signature: ::std::vec::Vec<u8>,
    pub guardian_addr: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignedHeartbeat {
    fn default() -> &'a SignedHeartbeat {
        <SignedHeartbeat as ::protobuf::Message>::default_instance()
    }
}

impl SignedHeartbeat {
    pub fn new() -> SignedHeartbeat {
        ::std::default::Default::default()
    }

    // bytes heartbeat = 1;


    pub fn get_heartbeat(&self) -> &[u8] {
        &self.heartbeat
    }
    pub fn clear_heartbeat(&mut self) {
        self.heartbeat.clear();
    }

    // Param is passed by value, moved
    pub fn set_heartbeat(&mut self, v: ::std::vec::Vec<u8>) {
        self.heartbeat = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_heartbeat(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.heartbeat
    }

    // Take field
    pub fn take_heartbeat(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.heartbeat, ::std::vec::Vec::new())
    }

    // bytes signature = 2;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // bytes guardian_addr = 3;


    pub fn get_guardian_addr(&self) -> &[u8] {
        &self.guardian_addr
    }
    pub fn clear_guardian_addr(&mut self) {
        self.guardian_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_guardian_addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.guardian_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guardian_addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.guardian_addr
    }

    // Take field
    pub fn take_guardian_addr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.guardian_addr, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SignedHeartbeat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.heartbeat)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.guardian_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.heartbeat.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.heartbeat);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signature);
        }
        if !self.guardian_addr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.guardian_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.heartbeat.is_empty() {
            os.write_bytes(1, &self.heartbeat)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(2, &self.signature)?;
        }
        if !self.guardian_addr.is_empty() {
            os.write_bytes(3, &self.guardian_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignedHeartbeat {
        SignedHeartbeat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "heartbeat",
                |m: &SignedHeartbeat| { &m.heartbeat },
                |m: &mut SignedHeartbeat| { &mut m.heartbeat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &SignedHeartbeat| { &m.signature },
                |m: &mut SignedHeartbeat| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "guardian_addr",
                |m: &SignedHeartbeat| { &m.guardian_addr },
                |m: &mut SignedHeartbeat| { &mut m.guardian_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignedHeartbeat>(
                "SignedHeartbeat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignedHeartbeat {
        static instance: ::protobuf::rt::LazyV2<SignedHeartbeat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignedHeartbeat::new)
    }
}

impl ::protobuf::Clear for SignedHeartbeat {
    fn clear(&mut self) {
        self.heartbeat.clear();
        self.signature.clear();
        self.guardian_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignedHeartbeat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedHeartbeat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Heartbeat {
    // message fields
    pub node_name: ::std::string::String,
    pub counter: i64,
    pub timestamp: i64,
    pub networks: ::protobuf::RepeatedField<Heartbeat_Network>,
    pub version: ::std::string::String,
    pub guardian_addr: ::std::string::String,
    pub boot_timestamp: i64,
    pub features: ::protobuf::RepeatedField<::std::string::String>,
    pub p2p_node_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Heartbeat {
    fn default() -> &'a Heartbeat {
        <Heartbeat as ::protobuf::Message>::default_instance()
    }
}

impl Heartbeat {
    pub fn new() -> Heartbeat {
        ::std::default::Default::default()
    }

    // string node_name = 1;


    pub fn get_node_name(&self) -> &str {
        &self.node_name
    }
    pub fn clear_node_name(&mut self) {
        self.node_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_name(&mut self, v: ::std::string::String) {
        self.node_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_name(&mut self) -> &mut ::std::string::String {
        &mut self.node_name
    }

    // Take field
    pub fn take_node_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_name, ::std::string::String::new())
    }

    // int64 counter = 2;


    pub fn get_counter(&self) -> i64 {
        self.counter
    }
    pub fn clear_counter(&mut self) {
        self.counter = 0;
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: i64) {
        self.counter = v;
    }

    // int64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // repeated .gossip.v1.Heartbeat.Network networks = 4;


    pub fn get_networks(&self) -> &[Heartbeat_Network] {
        &self.networks
    }
    pub fn clear_networks(&mut self) {
        self.networks.clear();
    }

    // Param is passed by value, moved
    pub fn set_networks(&mut self, v: ::protobuf::RepeatedField<Heartbeat_Network>) {
        self.networks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_networks(&mut self) -> &mut ::protobuf::RepeatedField<Heartbeat_Network> {
        &mut self.networks
    }

    // Take field
    pub fn take_networks(&mut self) -> ::protobuf::RepeatedField<Heartbeat_Network> {
        ::std::mem::replace(&mut self.networks, ::protobuf::RepeatedField::new())
    }

    // string version = 5;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string guardian_addr = 6;


    pub fn get_guardian_addr(&self) -> &str {
        &self.guardian_addr
    }
    pub fn clear_guardian_addr(&mut self) {
        self.guardian_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_guardian_addr(&mut self, v: ::std::string::String) {
        self.guardian_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guardian_addr(&mut self) -> &mut ::std::string::String {
        &mut self.guardian_addr
    }

    // Take field
    pub fn take_guardian_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.guardian_addr, ::std::string::String::new())
    }

    // int64 boot_timestamp = 7;


    pub fn get_boot_timestamp(&self) -> i64 {
        self.boot_timestamp
    }
    pub fn clear_boot_timestamp(&mut self) {
        self.boot_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_boot_timestamp(&mut self, v: i64) {
        self.boot_timestamp = v;
    }

    // repeated string features = 8;


    pub fn get_features(&self) -> &[::std::string::String] {
        &self.features
    }
    pub fn clear_features(&mut self) {
        self.features.clear();
    }

    // Param is passed by value, moved
    pub fn set_features(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_features(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.features
    }

    // Take field
    pub fn take_features(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.features, ::protobuf::RepeatedField::new())
    }

    // bytes p2p_node_id = 9;


    pub fn get_p2p_node_id(&self) -> &[u8] {
        &self.p2p_node_id
    }
    pub fn clear_p2p_node_id(&mut self) {
        self.p2p_node_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_p2p_node_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.p2p_node_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2p_node_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.p2p_node_id
    }

    // Take field
    pub fn take_p2p_node_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.p2p_node_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Heartbeat {
    fn is_initialized(&self) -> bool {
        for v in &self.networks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.counter = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.networks)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.guardian_addr)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.boot_timestamp = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.features)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.p2p_node_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.node_name);
        }
        if self.counter != 0 {
            my_size += ::protobuf::rt::value_size(2, self.counter, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.networks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.version);
        }
        if !self.guardian_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.guardian_addr);
        }
        if self.boot_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(7, self.boot_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.features {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if !self.p2p_node_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.p2p_node_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.node_name.is_empty() {
            os.write_string(1, &self.node_name)?;
        }
        if self.counter != 0 {
            os.write_int64(2, self.counter)?;
        }
        if self.timestamp != 0 {
            os.write_int64(3, self.timestamp)?;
        }
        for v in &self.networks {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.version.is_empty() {
            os.write_string(5, &self.version)?;
        }
        if !self.guardian_addr.is_empty() {
            os.write_string(6, &self.guardian_addr)?;
        }
        if self.boot_timestamp != 0 {
            os.write_int64(7, self.boot_timestamp)?;
        }
        for v in &self.features {
            os.write_string(8, &v)?;
        };
        if !self.p2p_node_id.is_empty() {
            os.write_bytes(9, &self.p2p_node_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Heartbeat {
        Heartbeat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_name",
                |m: &Heartbeat| { &m.node_name },
                |m: &mut Heartbeat| { &mut m.node_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "counter",
                |m: &Heartbeat| { &m.counter },
                |m: &mut Heartbeat| { &mut m.counter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &Heartbeat| { &m.timestamp },
                |m: &mut Heartbeat| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Heartbeat_Network>>(
                "networks",
                |m: &Heartbeat| { &m.networks },
                |m: &mut Heartbeat| { &mut m.networks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &Heartbeat| { &m.version },
                |m: &mut Heartbeat| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "guardian_addr",
                |m: &Heartbeat| { &m.guardian_addr },
                |m: &mut Heartbeat| { &mut m.guardian_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "boot_timestamp",
                |m: &Heartbeat| { &m.boot_timestamp },
                |m: &mut Heartbeat| { &mut m.boot_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "features",
                |m: &Heartbeat| { &m.features },
                |m: &mut Heartbeat| { &mut m.features },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "p2p_node_id",
                |m: &Heartbeat| { &m.p2p_node_id },
                |m: &mut Heartbeat| { &mut m.p2p_node_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Heartbeat>(
                "Heartbeat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Heartbeat {
        static instance: ::protobuf::rt::LazyV2<Heartbeat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Heartbeat::new)
    }
}

impl ::protobuf::Clear for Heartbeat {
    fn clear(&mut self) {
        self.node_name.clear();
        self.counter = 0;
        self.timestamp = 0;
        self.networks.clear();
        self.version.clear();
        self.guardian_addr.clear();
        self.boot_timestamp = 0;
        self.features.clear();
        self.p2p_node_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Heartbeat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Heartbeat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Heartbeat_Network {
    // message fields
    pub id: u32,
    pub height: i64,
    pub contract_address: ::std::string::String,
    pub error_count: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Heartbeat_Network {
    fn default() -> &'a Heartbeat_Network {
        <Heartbeat_Network as ::protobuf::Message>::default_instance()
    }
}

impl Heartbeat_Network {
    pub fn new() -> Heartbeat_Network {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // int64 height = 2;


    pub fn get_height(&self) -> i64 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i64) {
        self.height = v;
    }

    // string contract_address = 3;


    pub fn get_contract_address(&self) -> &str {
        &self.contract_address
    }
    pub fn clear_contract_address(&mut self) {
        self.contract_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_address(&mut self, v: ::std::string::String) {
        self.contract_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_address(&mut self) -> &mut ::std::string::String {
        &mut self.contract_address
    }

    // Take field
    pub fn take_contract_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contract_address, ::std::string::String::new())
    }

    // uint64 error_count = 4;


    pub fn get_error_count(&self) -> u64 {
        self.error_count
    }
    pub fn clear_error_count(&mut self) {
        self.error_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_error_count(&mut self, v: u64) {
        self.error_count = v;
    }
}

impl ::protobuf::Message for Heartbeat_Network {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.height = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.contract_address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.error_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.contract_address);
        }
        if self.error_count != 0 {
            my_size += ::protobuf::rt::value_size(4, self.error_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if self.height != 0 {
            os.write_int64(2, self.height)?;
        }
        if !self.contract_address.is_empty() {
            os.write_string(3, &self.contract_address)?;
        }
        if self.error_count != 0 {
            os.write_uint64(4, self.error_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Heartbeat_Network {
        Heartbeat_Network::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &Heartbeat_Network| { &m.id },
                |m: &mut Heartbeat_Network| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "height",
                |m: &Heartbeat_Network| { &m.height },
                |m: &mut Heartbeat_Network| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contract_address",
                |m: &Heartbeat_Network| { &m.contract_address },
                |m: &mut Heartbeat_Network| { &mut m.contract_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "error_count",
                |m: &Heartbeat_Network| { &m.error_count },
                |m: &mut Heartbeat_Network| { &mut m.error_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Heartbeat_Network>(
                "Heartbeat.Network",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Heartbeat_Network {
        static instance: ::protobuf::rt::LazyV2<Heartbeat_Network> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Heartbeat_Network::new)
    }
}

impl ::protobuf::Clear for Heartbeat_Network {
    fn clear(&mut self) {
        self.id = 0;
        self.height = 0;
        self.contract_address.clear();
        self.error_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Heartbeat_Network {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Heartbeat_Network {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignedObservation {
    // message fields
    pub addr: ::std::vec::Vec<u8>,
    pub hash: ::std::vec::Vec<u8>,
    pub signature: ::std::vec::Vec<u8>,
    pub tx_hash: ::std::vec::Vec<u8>,
    pub message_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignedObservation {
    fn default() -> &'a SignedObservation {
        <SignedObservation as ::protobuf::Message>::default_instance()
    }
}

impl SignedObservation {
    pub fn new() -> SignedObservation {
        ::std::default::Default::default()
    }

    // bytes addr = 1;


    pub fn get_addr(&self) -> &[u8] {
        &self.addr
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.addr
    }

    // Take field
    pub fn take_addr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.addr, ::std::vec::Vec::new())
    }

    // bytes hash = 2;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // bytes signature = 3;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // bytes tx_hash = 4;


    pub fn get_tx_hash(&self) -> &[u8] {
        &self.tx_hash
    }
    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.tx_hash, ::std::vec::Vec::new())
    }

    // string message_id = 5;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SignedObservation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.tx_hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.addr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.addr);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.signature);
        }
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.tx_hash);
        }
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.message_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.addr.is_empty() {
            os.write_bytes(1, &self.addr)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(3, &self.signature)?;
        }
        if !self.tx_hash.is_empty() {
            os.write_bytes(4, &self.tx_hash)?;
        }
        if !self.message_id.is_empty() {
            os.write_string(5, &self.message_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignedObservation {
        SignedObservation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "addr",
                |m: &SignedObservation| { &m.addr },
                |m: &mut SignedObservation| { &mut m.addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &SignedObservation| { &m.hash },
                |m: &mut SignedObservation| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &SignedObservation| { &m.signature },
                |m: &mut SignedObservation| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tx_hash",
                |m: &SignedObservation| { &m.tx_hash },
                |m: &mut SignedObservation| { &mut m.tx_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_id",
                |m: &SignedObservation| { &m.message_id },
                |m: &mut SignedObservation| { &mut m.message_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignedObservation>(
                "SignedObservation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignedObservation {
        static instance: ::protobuf::rt::LazyV2<SignedObservation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignedObservation::new)
    }
}

impl ::protobuf::Clear for SignedObservation {
    fn clear(&mut self) {
        self.addr.clear();
        self.hash.clear();
        self.signature.clear();
        self.tx_hash.clear();
        self.message_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignedObservation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedObservation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignedVAAWithQuorum {
    // message fields
    pub vaa: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignedVAAWithQuorum {
    fn default() -> &'a SignedVAAWithQuorum {
        <SignedVAAWithQuorum as ::protobuf::Message>::default_instance()
    }
}

impl SignedVAAWithQuorum {
    pub fn new() -> SignedVAAWithQuorum {
        ::std::default::Default::default()
    }

    // bytes vaa = 1;


    pub fn get_vaa(&self) -> &[u8] {
        &self.vaa
    }
    pub fn clear_vaa(&mut self) {
        self.vaa.clear();
    }

    // Param is passed by value, moved
    pub fn set_vaa(&mut self, v: ::std::vec::Vec<u8>) {
        self.vaa = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vaa(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.vaa
    }

    // Take field
    pub fn take_vaa(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.vaa, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SignedVAAWithQuorum {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.vaa)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.vaa.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.vaa);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.vaa.is_empty() {
            os.write_bytes(1, &self.vaa)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignedVAAWithQuorum {
        SignedVAAWithQuorum::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "vaa",
                |m: &SignedVAAWithQuorum| { &m.vaa },
                |m: &mut SignedVAAWithQuorum| { &mut m.vaa },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignedVAAWithQuorum>(
                "SignedVAAWithQuorum",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignedVAAWithQuorum {
        static instance: ::protobuf::rt::LazyV2<SignedVAAWithQuorum> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignedVAAWithQuorum::new)
    }
}

impl ::protobuf::Clear for SignedVAAWithQuorum {
    fn clear(&mut self) {
        self.vaa.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignedVAAWithQuorum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedVAAWithQuorum {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignedObservationRequest {
    // message fields
    pub observation_request: ::std::vec::Vec<u8>,
    pub signature: ::std::vec::Vec<u8>,
    pub guardian_addr: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignedObservationRequest {
    fn default() -> &'a SignedObservationRequest {
        <SignedObservationRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignedObservationRequest {
    pub fn new() -> SignedObservationRequest {
        ::std::default::Default::default()
    }

    // bytes observation_request = 1;


    pub fn get_observation_request(&self) -> &[u8] {
        &self.observation_request
    }
    pub fn clear_observation_request(&mut self) {
        self.observation_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_observation_request(&mut self, v: ::std::vec::Vec<u8>) {
        self.observation_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_observation_request(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.observation_request
    }

    // Take field
    pub fn take_observation_request(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.observation_request, ::std::vec::Vec::new())
    }

    // bytes signature = 2;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // bytes guardian_addr = 3;


    pub fn get_guardian_addr(&self) -> &[u8] {
        &self.guardian_addr
    }
    pub fn clear_guardian_addr(&mut self) {
        self.guardian_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_guardian_addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.guardian_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guardian_addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.guardian_addr
    }

    // Take field
    pub fn take_guardian_addr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.guardian_addr, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SignedObservationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.observation_request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.guardian_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.observation_request.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.observation_request);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signature);
        }
        if !self.guardian_addr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.guardian_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.observation_request.is_empty() {
            os.write_bytes(1, &self.observation_request)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(2, &self.signature)?;
        }
        if !self.guardian_addr.is_empty() {
            os.write_bytes(3, &self.guardian_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignedObservationRequest {
        SignedObservationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "observation_request",
                |m: &SignedObservationRequest| { &m.observation_request },
                |m: &mut SignedObservationRequest| { &mut m.observation_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &SignedObservationRequest| { &m.signature },
                |m: &mut SignedObservationRequest| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "guardian_addr",
                |m: &SignedObservationRequest| { &m.guardian_addr },
                |m: &mut SignedObservationRequest| { &mut m.guardian_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignedObservationRequest>(
                "SignedObservationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignedObservationRequest {
        static instance: ::protobuf::rt::LazyV2<SignedObservationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignedObservationRequest::new)
    }
}

impl ::protobuf::Clear for SignedObservationRequest {
    fn clear(&mut self) {
        self.observation_request.clear();
        self.signature.clear();
        self.guardian_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignedObservationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedObservationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObservationRequest {
    // message fields
    pub chain_id: u32,
    pub tx_hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ObservationRequest {
    fn default() -> &'a ObservationRequest {
        <ObservationRequest as ::protobuf::Message>::default_instance()
    }
}

impl ObservationRequest {
    pub fn new() -> ObservationRequest {
        ::std::default::Default::default()
    }

    // uint32 chain_id = 1;


    pub fn get_chain_id(&self) -> u32 {
        self.chain_id
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: u32) {
        self.chain_id = v;
    }

    // bytes tx_hash = 2;


    pub fn get_tx_hash(&self) -> &[u8] {
        &self.tx_hash
    }
    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.tx_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ObservationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.chain_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.tx_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chain_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chain_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.tx_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chain_id != 0 {
            os.write_uint32(1, self.chain_id)?;
        }
        if !self.tx_hash.is_empty() {
            os.write_bytes(2, &self.tx_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObservationRequest {
        ObservationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "chain_id",
                |m: &ObservationRequest| { &m.chain_id },
                |m: &mut ObservationRequest| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tx_hash",
                |m: &ObservationRequest| { &m.tx_hash },
                |m: &mut ObservationRequest| { &mut m.tx_hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ObservationRequest>(
                "ObservationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ObservationRequest {
        static instance: ::protobuf::rt::LazyV2<ObservationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ObservationRequest::new)
    }
}

impl ::protobuf::Clear for ObservationRequest {
    fn clear(&mut self) {
        self.chain_id = 0;
        self.tx_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObservationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignedBatchObservation {
    // message fields
    pub addr: ::std::vec::Vec<u8>,
    pub hash: ::std::vec::Vec<u8>,
    pub signature: ::std::vec::Vec<u8>,
    pub tx_id: ::std::vec::Vec<u8>,
    pub chain_id: u32,
    pub nonce: u32,
    pub batch_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignedBatchObservation {
    fn default() -> &'a SignedBatchObservation {
        <SignedBatchObservation as ::protobuf::Message>::default_instance()
    }
}

impl SignedBatchObservation {
    pub fn new() -> SignedBatchObservation {
        ::std::default::Default::default()
    }

    // bytes addr = 1;


    pub fn get_addr(&self) -> &[u8] {
        &self.addr
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.addr
    }

    // Take field
    pub fn take_addr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.addr, ::std::vec::Vec::new())
    }

    // bytes hash = 2;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // bytes signature = 3;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // bytes tx_id = 4;


    pub fn get_tx_id(&self) -> &[u8] {
        &self.tx_id
    }
    pub fn clear_tx_id(&mut self) {
        self.tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.tx_id
    }

    // Take field
    pub fn take_tx_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.tx_id, ::std::vec::Vec::new())
    }

    // uint32 chain_id = 5;


    pub fn get_chain_id(&self) -> u32 {
        self.chain_id
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: u32) {
        self.chain_id = v;
    }

    // uint32 nonce = 6;


    pub fn get_nonce(&self) -> u32 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u32) {
        self.nonce = v;
    }

    // string batch_id = 7;


    pub fn get_batch_id(&self) -> &str {
        &self.batch_id
    }
    pub fn clear_batch_id(&mut self) {
        self.batch_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_batch_id(&mut self, v: ::std::string::String) {
        self.batch_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_batch_id(&mut self) -> &mut ::std::string::String {
        &mut self.batch_id
    }

    // Take field
    pub fn take_batch_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.batch_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SignedBatchObservation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.tx_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.chain_id = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nonce = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.batch_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.addr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.addr);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.signature);
        }
        if !self.tx_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.tx_id);
        }
        if self.chain_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.chain_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(6, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.batch_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.batch_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.addr.is_empty() {
            os.write_bytes(1, &self.addr)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(3, &self.signature)?;
        }
        if !self.tx_id.is_empty() {
            os.write_bytes(4, &self.tx_id)?;
        }
        if self.chain_id != 0 {
            os.write_uint32(5, self.chain_id)?;
        }
        if self.nonce != 0 {
            os.write_uint32(6, self.nonce)?;
        }
        if !self.batch_id.is_empty() {
            os.write_string(7, &self.batch_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignedBatchObservation {
        SignedBatchObservation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "addr",
                |m: &SignedBatchObservation| { &m.addr },
                |m: &mut SignedBatchObservation| { &mut m.addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &SignedBatchObservation| { &m.hash },
                |m: &mut SignedBatchObservation| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &SignedBatchObservation| { &m.signature },
                |m: &mut SignedBatchObservation| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tx_id",
                |m: &SignedBatchObservation| { &m.tx_id },
                |m: &mut SignedBatchObservation| { &mut m.tx_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "chain_id",
                |m: &SignedBatchObservation| { &m.chain_id },
                |m: &mut SignedBatchObservation| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nonce",
                |m: &SignedBatchObservation| { &m.nonce },
                |m: &mut SignedBatchObservation| { &mut m.nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "batch_id",
                |m: &SignedBatchObservation| { &m.batch_id },
                |m: &mut SignedBatchObservation| { &mut m.batch_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignedBatchObservation>(
                "SignedBatchObservation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignedBatchObservation {
        static instance: ::protobuf::rt::LazyV2<SignedBatchObservation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignedBatchObservation::new)
    }
}

impl ::protobuf::Clear for SignedBatchObservation {
    fn clear(&mut self) {
        self.addr.clear();
        self.hash.clear();
        self.signature.clear();
        self.tx_id.clear();
        self.chain_id = 0;
        self.nonce = 0;
        self.batch_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignedBatchObservation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedBatchObservation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignedBatchVAAWithQuorum {
    // message fields
    pub batch_vaa: ::std::vec::Vec<u8>,
    pub chain_id: u32,
    pub tx_id: ::std::vec::Vec<u8>,
    pub nonce: u32,
    pub batch_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignedBatchVAAWithQuorum {
    fn default() -> &'a SignedBatchVAAWithQuorum {
        <SignedBatchVAAWithQuorum as ::protobuf::Message>::default_instance()
    }
}

impl SignedBatchVAAWithQuorum {
    pub fn new() -> SignedBatchVAAWithQuorum {
        ::std::default::Default::default()
    }

    // bytes batch_vaa = 1;


    pub fn get_batch_vaa(&self) -> &[u8] {
        &self.batch_vaa
    }
    pub fn clear_batch_vaa(&mut self) {
        self.batch_vaa.clear();
    }

    // Param is passed by value, moved
    pub fn set_batch_vaa(&mut self, v: ::std::vec::Vec<u8>) {
        self.batch_vaa = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_batch_vaa(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.batch_vaa
    }

    // Take field
    pub fn take_batch_vaa(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.batch_vaa, ::std::vec::Vec::new())
    }

    // uint32 chain_id = 2;


    pub fn get_chain_id(&self) -> u32 {
        self.chain_id
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: u32) {
        self.chain_id = v;
    }

    // bytes tx_id = 3;


    pub fn get_tx_id(&self) -> &[u8] {
        &self.tx_id
    }
    pub fn clear_tx_id(&mut self) {
        self.tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.tx_id
    }

    // Take field
    pub fn take_tx_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.tx_id, ::std::vec::Vec::new())
    }

    // uint32 nonce = 4;


    pub fn get_nonce(&self) -> u32 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u32) {
        self.nonce = v;
    }

    // string batch_id = 5;


    pub fn get_batch_id(&self) -> &str {
        &self.batch_id
    }
    pub fn clear_batch_id(&mut self) {
        self.batch_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_batch_id(&mut self, v: ::std::string::String) {
        self.batch_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_batch_id(&mut self) -> &mut ::std::string::String {
        &mut self.batch_id
    }

    // Take field
    pub fn take_batch_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.batch_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SignedBatchVAAWithQuorum {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.batch_vaa)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.chain_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.tx_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nonce = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.batch_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.batch_vaa.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.batch_vaa);
        }
        if self.chain_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.chain_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.tx_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.tx_id);
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(4, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.batch_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.batch_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.batch_vaa.is_empty() {
            os.write_bytes(1, &self.batch_vaa)?;
        }
        if self.chain_id != 0 {
            os.write_uint32(2, self.chain_id)?;
        }
        if !self.tx_id.is_empty() {
            os.write_bytes(3, &self.tx_id)?;
        }
        if self.nonce != 0 {
            os.write_uint32(4, self.nonce)?;
        }
        if !self.batch_id.is_empty() {
            os.write_string(5, &self.batch_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignedBatchVAAWithQuorum {
        SignedBatchVAAWithQuorum::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "batch_vaa",
                |m: &SignedBatchVAAWithQuorum| { &m.batch_vaa },
                |m: &mut SignedBatchVAAWithQuorum| { &mut m.batch_vaa },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "chain_id",
                |m: &SignedBatchVAAWithQuorum| { &m.chain_id },
                |m: &mut SignedBatchVAAWithQuorum| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tx_id",
                |m: &SignedBatchVAAWithQuorum| { &m.tx_id },
                |m: &mut SignedBatchVAAWithQuorum| { &mut m.tx_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nonce",
                |m: &SignedBatchVAAWithQuorum| { &m.nonce },
                |m: &mut SignedBatchVAAWithQuorum| { &mut m.nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "batch_id",
                |m: &SignedBatchVAAWithQuorum| { &m.batch_id },
                |m: &mut SignedBatchVAAWithQuorum| { &mut m.batch_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignedBatchVAAWithQuorum>(
                "SignedBatchVAAWithQuorum",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignedBatchVAAWithQuorum {
        static instance: ::protobuf::rt::LazyV2<SignedBatchVAAWithQuorum> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignedBatchVAAWithQuorum::new)
    }
}

impl ::protobuf::Clear for SignedBatchVAAWithQuorum {
    fn clear(&mut self) {
        self.batch_vaa.clear();
        self.chain_id = 0;
        self.tx_id.clear();
        self.nonce = 0;
        self.batch_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignedBatchVAAWithQuorum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedBatchVAAWithQuorum {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignedChainGovernorConfig {
    // message fields
    pub config: ::std::vec::Vec<u8>,
    pub signature: ::std::vec::Vec<u8>,
    pub guardian_addr: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignedChainGovernorConfig {
    fn default() -> &'a SignedChainGovernorConfig {
        <SignedChainGovernorConfig as ::protobuf::Message>::default_instance()
    }
}

impl SignedChainGovernorConfig {
    pub fn new() -> SignedChainGovernorConfig {
        ::std::default::Default::default()
    }

    // bytes config = 1;


    pub fn get_config(&self) -> &[u8] {
        &self.config
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::std::vec::Vec<u8>) {
        self.config = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.config
    }

    // Take field
    pub fn take_config(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.config, ::std::vec::Vec::new())
    }

    // bytes signature = 2;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // bytes guardian_addr = 3;


    pub fn get_guardian_addr(&self) -> &[u8] {
        &self.guardian_addr
    }
    pub fn clear_guardian_addr(&mut self) {
        self.guardian_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_guardian_addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.guardian_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guardian_addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.guardian_addr
    }

    // Take field
    pub fn take_guardian_addr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.guardian_addr, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SignedChainGovernorConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.guardian_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.config.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.config);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signature);
        }
        if !self.guardian_addr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.guardian_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.config.is_empty() {
            os.write_bytes(1, &self.config)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(2, &self.signature)?;
        }
        if !self.guardian_addr.is_empty() {
            os.write_bytes(3, &self.guardian_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignedChainGovernorConfig {
        SignedChainGovernorConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "config",
                |m: &SignedChainGovernorConfig| { &m.config },
                |m: &mut SignedChainGovernorConfig| { &mut m.config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &SignedChainGovernorConfig| { &m.signature },
                |m: &mut SignedChainGovernorConfig| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "guardian_addr",
                |m: &SignedChainGovernorConfig| { &m.guardian_addr },
                |m: &mut SignedChainGovernorConfig| { &mut m.guardian_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignedChainGovernorConfig>(
                "SignedChainGovernorConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignedChainGovernorConfig {
        static instance: ::protobuf::rt::LazyV2<SignedChainGovernorConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignedChainGovernorConfig::new)
    }
}

impl ::protobuf::Clear for SignedChainGovernorConfig {
    fn clear(&mut self) {
        self.config.clear();
        self.signature.clear();
        self.guardian_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignedChainGovernorConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedChainGovernorConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChainGovernorConfig {
    // message fields
    pub node_name: ::std::string::String,
    pub counter: i64,
    pub timestamp: i64,
    pub chains: ::protobuf::RepeatedField<ChainGovernorConfig_Chain>,
    pub tokens: ::protobuf::RepeatedField<ChainGovernorConfig_Token>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainGovernorConfig {
    fn default() -> &'a ChainGovernorConfig {
        <ChainGovernorConfig as ::protobuf::Message>::default_instance()
    }
}

impl ChainGovernorConfig {
    pub fn new() -> ChainGovernorConfig {
        ::std::default::Default::default()
    }

    // string node_name = 1;


    pub fn get_node_name(&self) -> &str {
        &self.node_name
    }
    pub fn clear_node_name(&mut self) {
        self.node_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_name(&mut self, v: ::std::string::String) {
        self.node_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_name(&mut self) -> &mut ::std::string::String {
        &mut self.node_name
    }

    // Take field
    pub fn take_node_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_name, ::std::string::String::new())
    }

    // int64 counter = 2;


    pub fn get_counter(&self) -> i64 {
        self.counter
    }
    pub fn clear_counter(&mut self) {
        self.counter = 0;
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: i64) {
        self.counter = v;
    }

    // int64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // repeated .gossip.v1.ChainGovernorConfig.Chain chains = 4;


    pub fn get_chains(&self) -> &[ChainGovernorConfig_Chain] {
        &self.chains
    }
    pub fn clear_chains(&mut self) {
        self.chains.clear();
    }

    // Param is passed by value, moved
    pub fn set_chains(&mut self, v: ::protobuf::RepeatedField<ChainGovernorConfig_Chain>) {
        self.chains = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chains(&mut self) -> &mut ::protobuf::RepeatedField<ChainGovernorConfig_Chain> {
        &mut self.chains
    }

    // Take field
    pub fn take_chains(&mut self) -> ::protobuf::RepeatedField<ChainGovernorConfig_Chain> {
        ::std::mem::replace(&mut self.chains, ::protobuf::RepeatedField::new())
    }

    // repeated .gossip.v1.ChainGovernorConfig.Token tokens = 5;


    pub fn get_tokens(&self) -> &[ChainGovernorConfig_Token] {
        &self.tokens
    }
    pub fn clear_tokens(&mut self) {
        self.tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: ::protobuf::RepeatedField<ChainGovernorConfig_Token>) {
        self.tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tokens(&mut self) -> &mut ::protobuf::RepeatedField<ChainGovernorConfig_Token> {
        &mut self.tokens
    }

    // Take field
    pub fn take_tokens(&mut self) -> ::protobuf::RepeatedField<ChainGovernorConfig_Token> {
        ::std::mem::replace(&mut self.tokens, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChainGovernorConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.chains {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tokens {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.counter = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chains)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tokens)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.node_name);
        }
        if self.counter != 0 {
            my_size += ::protobuf::rt::value_size(2, self.counter, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.chains {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.node_name.is_empty() {
            os.write_string(1, &self.node_name)?;
        }
        if self.counter != 0 {
            os.write_int64(2, self.counter)?;
        }
        if self.timestamp != 0 {
            os.write_int64(3, self.timestamp)?;
        }
        for v in &self.chains {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tokens {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainGovernorConfig {
        ChainGovernorConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_name",
                |m: &ChainGovernorConfig| { &m.node_name },
                |m: &mut ChainGovernorConfig| { &mut m.node_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "counter",
                |m: &ChainGovernorConfig| { &m.counter },
                |m: &mut ChainGovernorConfig| { &mut m.counter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &ChainGovernorConfig| { &m.timestamp },
                |m: &mut ChainGovernorConfig| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChainGovernorConfig_Chain>>(
                "chains",
                |m: &ChainGovernorConfig| { &m.chains },
                |m: &mut ChainGovernorConfig| { &mut m.chains },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChainGovernorConfig_Token>>(
                "tokens",
                |m: &ChainGovernorConfig| { &m.tokens },
                |m: &mut ChainGovernorConfig| { &mut m.tokens },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChainGovernorConfig>(
                "ChainGovernorConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChainGovernorConfig {
        static instance: ::protobuf::rt::LazyV2<ChainGovernorConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChainGovernorConfig::new)
    }
}

impl ::protobuf::Clear for ChainGovernorConfig {
    fn clear(&mut self) {
        self.node_name.clear();
        self.counter = 0;
        self.timestamp = 0;
        self.chains.clear();
        self.tokens.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainGovernorConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainGovernorConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChainGovernorConfig_Chain {
    // message fields
    pub chain_id: u32,
    pub notional_limit: u64,
    pub big_transaction_size: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainGovernorConfig_Chain {
    fn default() -> &'a ChainGovernorConfig_Chain {
        <ChainGovernorConfig_Chain as ::protobuf::Message>::default_instance()
    }
}

impl ChainGovernorConfig_Chain {
    pub fn new() -> ChainGovernorConfig_Chain {
        ::std::default::Default::default()
    }

    // uint32 chain_id = 1;


    pub fn get_chain_id(&self) -> u32 {
        self.chain_id
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: u32) {
        self.chain_id = v;
    }

    // uint64 notional_limit = 2;


    pub fn get_notional_limit(&self) -> u64 {
        self.notional_limit
    }
    pub fn clear_notional_limit(&mut self) {
        self.notional_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_notional_limit(&mut self, v: u64) {
        self.notional_limit = v;
    }

    // uint64 big_transaction_size = 3;


    pub fn get_big_transaction_size(&self) -> u64 {
        self.big_transaction_size
    }
    pub fn clear_big_transaction_size(&mut self) {
        self.big_transaction_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_big_transaction_size(&mut self, v: u64) {
        self.big_transaction_size = v;
    }
}

impl ::protobuf::Message for ChainGovernorConfig_Chain {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.chain_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.notional_limit = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.big_transaction_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chain_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chain_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.notional_limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.notional_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.big_transaction_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.big_transaction_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chain_id != 0 {
            os.write_uint32(1, self.chain_id)?;
        }
        if self.notional_limit != 0 {
            os.write_uint64(2, self.notional_limit)?;
        }
        if self.big_transaction_size != 0 {
            os.write_uint64(3, self.big_transaction_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainGovernorConfig_Chain {
        ChainGovernorConfig_Chain::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "chain_id",
                |m: &ChainGovernorConfig_Chain| { &m.chain_id },
                |m: &mut ChainGovernorConfig_Chain| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "notional_limit",
                |m: &ChainGovernorConfig_Chain| { &m.notional_limit },
                |m: &mut ChainGovernorConfig_Chain| { &mut m.notional_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "big_transaction_size",
                |m: &ChainGovernorConfig_Chain| { &m.big_transaction_size },
                |m: &mut ChainGovernorConfig_Chain| { &mut m.big_transaction_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChainGovernorConfig_Chain>(
                "ChainGovernorConfig.Chain",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChainGovernorConfig_Chain {
        static instance: ::protobuf::rt::LazyV2<ChainGovernorConfig_Chain> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChainGovernorConfig_Chain::new)
    }
}

impl ::protobuf::Clear for ChainGovernorConfig_Chain {
    fn clear(&mut self) {
        self.chain_id = 0;
        self.notional_limit = 0;
        self.big_transaction_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainGovernorConfig_Chain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainGovernorConfig_Chain {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChainGovernorConfig_Token {
    // message fields
    pub origin_chain_id: u32,
    pub origin_address: ::std::string::String,
    pub price: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainGovernorConfig_Token {
    fn default() -> &'a ChainGovernorConfig_Token {
        <ChainGovernorConfig_Token as ::protobuf::Message>::default_instance()
    }
}

impl ChainGovernorConfig_Token {
    pub fn new() -> ChainGovernorConfig_Token {
        ::std::default::Default::default()
    }

    // uint32 origin_chain_id = 1;


    pub fn get_origin_chain_id(&self) -> u32 {
        self.origin_chain_id
    }
    pub fn clear_origin_chain_id(&mut self) {
        self.origin_chain_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_origin_chain_id(&mut self, v: u32) {
        self.origin_chain_id = v;
    }

    // string origin_address = 2;


    pub fn get_origin_address(&self) -> &str {
        &self.origin_address
    }
    pub fn clear_origin_address(&mut self) {
        self.origin_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_origin_address(&mut self, v: ::std::string::String) {
        self.origin_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin_address(&mut self) -> &mut ::std::string::String {
        &mut self.origin_address
    }

    // Take field
    pub fn take_origin_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.origin_address, ::std::string::String::new())
    }

    // float price = 3;


    pub fn get_price(&self) -> f32 {
        self.price
    }
    pub fn clear_price(&mut self) {
        self.price = 0.;
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: f32) {
        self.price = v;
    }
}

impl ::protobuf::Message for ChainGovernorConfig_Token {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.origin_chain_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.origin_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.price = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.origin_chain_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.origin_chain_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.origin_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.origin_address);
        }
        if self.price != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.origin_chain_id != 0 {
            os.write_uint32(1, self.origin_chain_id)?;
        }
        if !self.origin_address.is_empty() {
            os.write_string(2, &self.origin_address)?;
        }
        if self.price != 0. {
            os.write_float(3, self.price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainGovernorConfig_Token {
        ChainGovernorConfig_Token::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "origin_chain_id",
                |m: &ChainGovernorConfig_Token| { &m.origin_chain_id },
                |m: &mut ChainGovernorConfig_Token| { &mut m.origin_chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "origin_address",
                |m: &ChainGovernorConfig_Token| { &m.origin_address },
                |m: &mut ChainGovernorConfig_Token| { &mut m.origin_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "price",
                |m: &ChainGovernorConfig_Token| { &m.price },
                |m: &mut ChainGovernorConfig_Token| { &mut m.price },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChainGovernorConfig_Token>(
                "ChainGovernorConfig.Token",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChainGovernorConfig_Token {
        static instance: ::protobuf::rt::LazyV2<ChainGovernorConfig_Token> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChainGovernorConfig_Token::new)
    }
}

impl ::protobuf::Clear for ChainGovernorConfig_Token {
    fn clear(&mut self) {
        self.origin_chain_id = 0;
        self.origin_address.clear();
        self.price = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainGovernorConfig_Token {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainGovernorConfig_Token {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignedChainGovernorStatus {
    // message fields
    pub status: ::std::vec::Vec<u8>,
    pub signature: ::std::vec::Vec<u8>,
    pub guardian_addr: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignedChainGovernorStatus {
    fn default() -> &'a SignedChainGovernorStatus {
        <SignedChainGovernorStatus as ::protobuf::Message>::default_instance()
    }
}

impl SignedChainGovernorStatus {
    pub fn new() -> SignedChainGovernorStatus {
        ::std::default::Default::default()
    }

    // bytes status = 1;


    pub fn get_status(&self) -> &[u8] {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::vec::Vec<u8>) {
        self.status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.status, ::std::vec::Vec::new())
    }

    // bytes signature = 2;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // bytes guardian_addr = 3;


    pub fn get_guardian_addr(&self) -> &[u8] {
        &self.guardian_addr
    }
    pub fn clear_guardian_addr(&mut self) {
        self.guardian_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_guardian_addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.guardian_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guardian_addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.guardian_addr
    }

    // Take field
    pub fn take_guardian_addr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.guardian_addr, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SignedChainGovernorStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.guardian_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.status);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signature);
        }
        if !self.guardian_addr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.guardian_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.status.is_empty() {
            os.write_bytes(1, &self.status)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(2, &self.signature)?;
        }
        if !self.guardian_addr.is_empty() {
            os.write_bytes(3, &self.guardian_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignedChainGovernorStatus {
        SignedChainGovernorStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "status",
                |m: &SignedChainGovernorStatus| { &m.status },
                |m: &mut SignedChainGovernorStatus| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &SignedChainGovernorStatus| { &m.signature },
                |m: &mut SignedChainGovernorStatus| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "guardian_addr",
                |m: &SignedChainGovernorStatus| { &m.guardian_addr },
                |m: &mut SignedChainGovernorStatus| { &mut m.guardian_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignedChainGovernorStatus>(
                "SignedChainGovernorStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignedChainGovernorStatus {
        static instance: ::protobuf::rt::LazyV2<SignedChainGovernorStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignedChainGovernorStatus::new)
    }
}

impl ::protobuf::Clear for SignedChainGovernorStatus {
    fn clear(&mut self) {
        self.status.clear();
        self.signature.clear();
        self.guardian_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignedChainGovernorStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedChainGovernorStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChainGovernorStatus {
    // message fields
    pub node_name: ::std::string::String,
    pub counter: i64,
    pub timestamp: i64,
    pub chains: ::protobuf::RepeatedField<ChainGovernorStatus_Chain>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainGovernorStatus {
    fn default() -> &'a ChainGovernorStatus {
        <ChainGovernorStatus as ::protobuf::Message>::default_instance()
    }
}

impl ChainGovernorStatus {
    pub fn new() -> ChainGovernorStatus {
        ::std::default::Default::default()
    }

    // string node_name = 1;


    pub fn get_node_name(&self) -> &str {
        &self.node_name
    }
    pub fn clear_node_name(&mut self) {
        self.node_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_name(&mut self, v: ::std::string::String) {
        self.node_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_name(&mut self) -> &mut ::std::string::String {
        &mut self.node_name
    }

    // Take field
    pub fn take_node_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_name, ::std::string::String::new())
    }

    // int64 counter = 2;


    pub fn get_counter(&self) -> i64 {
        self.counter
    }
    pub fn clear_counter(&mut self) {
        self.counter = 0;
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: i64) {
        self.counter = v;
    }

    // int64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // repeated .gossip.v1.ChainGovernorStatus.Chain chains = 4;


    pub fn get_chains(&self) -> &[ChainGovernorStatus_Chain] {
        &self.chains
    }
    pub fn clear_chains(&mut self) {
        self.chains.clear();
    }

    // Param is passed by value, moved
    pub fn set_chains(&mut self, v: ::protobuf::RepeatedField<ChainGovernorStatus_Chain>) {
        self.chains = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chains(&mut self) -> &mut ::protobuf::RepeatedField<ChainGovernorStatus_Chain> {
        &mut self.chains
    }

    // Take field
    pub fn take_chains(&mut self) -> ::protobuf::RepeatedField<ChainGovernorStatus_Chain> {
        ::std::mem::replace(&mut self.chains, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChainGovernorStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.chains {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.counter = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chains)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.node_name);
        }
        if self.counter != 0 {
            my_size += ::protobuf::rt::value_size(2, self.counter, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.chains {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.node_name.is_empty() {
            os.write_string(1, &self.node_name)?;
        }
        if self.counter != 0 {
            os.write_int64(2, self.counter)?;
        }
        if self.timestamp != 0 {
            os.write_int64(3, self.timestamp)?;
        }
        for v in &self.chains {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainGovernorStatus {
        ChainGovernorStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_name",
                |m: &ChainGovernorStatus| { &m.node_name },
                |m: &mut ChainGovernorStatus| { &mut m.node_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "counter",
                |m: &ChainGovernorStatus| { &m.counter },
                |m: &mut ChainGovernorStatus| { &mut m.counter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &ChainGovernorStatus| { &m.timestamp },
                |m: &mut ChainGovernorStatus| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChainGovernorStatus_Chain>>(
                "chains",
                |m: &ChainGovernorStatus| { &m.chains },
                |m: &mut ChainGovernorStatus| { &mut m.chains },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChainGovernorStatus>(
                "ChainGovernorStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChainGovernorStatus {
        static instance: ::protobuf::rt::LazyV2<ChainGovernorStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChainGovernorStatus::new)
    }
}

impl ::protobuf::Clear for ChainGovernorStatus {
    fn clear(&mut self) {
        self.node_name.clear();
        self.counter = 0;
        self.timestamp = 0;
        self.chains.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainGovernorStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainGovernorStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChainGovernorStatus_EnqueuedVAA {
    // message fields
    pub sequence: u64,
    pub release_time: u32,
    pub notional_value: u64,
    pub tx_hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainGovernorStatus_EnqueuedVAA {
    fn default() -> &'a ChainGovernorStatus_EnqueuedVAA {
        <ChainGovernorStatus_EnqueuedVAA as ::protobuf::Message>::default_instance()
    }
}

impl ChainGovernorStatus_EnqueuedVAA {
    pub fn new() -> ChainGovernorStatus_EnqueuedVAA {
        ::std::default::Default::default()
    }

    // uint64 sequence = 1;


    pub fn get_sequence(&self) -> u64 {
        self.sequence
    }
    pub fn clear_sequence(&mut self) {
        self.sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u64) {
        self.sequence = v;
    }

    // uint32 release_time = 2;


    pub fn get_release_time(&self) -> u32 {
        self.release_time
    }
    pub fn clear_release_time(&mut self) {
        self.release_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_release_time(&mut self, v: u32) {
        self.release_time = v;
    }

    // uint64 notional_value = 3;


    pub fn get_notional_value(&self) -> u64 {
        self.notional_value
    }
    pub fn clear_notional_value(&mut self) {
        self.notional_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_notional_value(&mut self, v: u64) {
        self.notional_value = v;
    }

    // string tx_hash = 4;


    pub fn get_tx_hash(&self) -> &str {
        &self.tx_hash
    }
    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::string::String) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ChainGovernorStatus_EnqueuedVAA {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.release_time = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.notional_value = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.sequence != 0 {
            my_size += ::protobuf::rt::value_size(1, self.sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.release_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.release_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.notional_value != 0 {
            my_size += ::protobuf::rt::value_size(3, self.notional_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.tx_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.sequence != 0 {
            os.write_uint64(1, self.sequence)?;
        }
        if self.release_time != 0 {
            os.write_uint32(2, self.release_time)?;
        }
        if self.notional_value != 0 {
            os.write_uint64(3, self.notional_value)?;
        }
        if !self.tx_hash.is_empty() {
            os.write_string(4, &self.tx_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainGovernorStatus_EnqueuedVAA {
        ChainGovernorStatus_EnqueuedVAA::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sequence",
                |m: &ChainGovernorStatus_EnqueuedVAA| { &m.sequence },
                |m: &mut ChainGovernorStatus_EnqueuedVAA| { &mut m.sequence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "release_time",
                |m: &ChainGovernorStatus_EnqueuedVAA| { &m.release_time },
                |m: &mut ChainGovernorStatus_EnqueuedVAA| { &mut m.release_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "notional_value",
                |m: &ChainGovernorStatus_EnqueuedVAA| { &m.notional_value },
                |m: &mut ChainGovernorStatus_EnqueuedVAA| { &mut m.notional_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tx_hash",
                |m: &ChainGovernorStatus_EnqueuedVAA| { &m.tx_hash },
                |m: &mut ChainGovernorStatus_EnqueuedVAA| { &mut m.tx_hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChainGovernorStatus_EnqueuedVAA>(
                "ChainGovernorStatus.EnqueuedVAA",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChainGovernorStatus_EnqueuedVAA {
        static instance: ::protobuf::rt::LazyV2<ChainGovernorStatus_EnqueuedVAA> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChainGovernorStatus_EnqueuedVAA::new)
    }
}

impl ::protobuf::Clear for ChainGovernorStatus_EnqueuedVAA {
    fn clear(&mut self) {
        self.sequence = 0;
        self.release_time = 0;
        self.notional_value = 0;
        self.tx_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainGovernorStatus_EnqueuedVAA {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainGovernorStatus_EnqueuedVAA {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChainGovernorStatus_Emitter {
    // message fields
    pub emitter_address: ::std::string::String,
    pub total_enqueued_vaas: u64,
    pub enqueued_vaas: ::protobuf::RepeatedField<ChainGovernorStatus_EnqueuedVAA>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainGovernorStatus_Emitter {
    fn default() -> &'a ChainGovernorStatus_Emitter {
        <ChainGovernorStatus_Emitter as ::protobuf::Message>::default_instance()
    }
}

impl ChainGovernorStatus_Emitter {
    pub fn new() -> ChainGovernorStatus_Emitter {
        ::std::default::Default::default()
    }

    // string emitter_address = 1;


    pub fn get_emitter_address(&self) -> &str {
        &self.emitter_address
    }
    pub fn clear_emitter_address(&mut self) {
        self.emitter_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_emitter_address(&mut self, v: ::std::string::String) {
        self.emitter_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emitter_address(&mut self) -> &mut ::std::string::String {
        &mut self.emitter_address
    }

    // Take field
    pub fn take_emitter_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.emitter_address, ::std::string::String::new())
    }

    // uint64 total_enqueued_vaas = 2;


    pub fn get_total_enqueued_vaas(&self) -> u64 {
        self.total_enqueued_vaas
    }
    pub fn clear_total_enqueued_vaas(&mut self) {
        self.total_enqueued_vaas = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_enqueued_vaas(&mut self, v: u64) {
        self.total_enqueued_vaas = v;
    }

    // repeated .gossip.v1.ChainGovernorStatus.EnqueuedVAA enqueued_vaas = 3;


    pub fn get_enqueued_vaas(&self) -> &[ChainGovernorStatus_EnqueuedVAA] {
        &self.enqueued_vaas
    }
    pub fn clear_enqueued_vaas(&mut self) {
        self.enqueued_vaas.clear();
    }

    // Param is passed by value, moved
    pub fn set_enqueued_vaas(&mut self, v: ::protobuf::RepeatedField<ChainGovernorStatus_EnqueuedVAA>) {
        self.enqueued_vaas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enqueued_vaas(&mut self) -> &mut ::protobuf::RepeatedField<ChainGovernorStatus_EnqueuedVAA> {
        &mut self.enqueued_vaas
    }

    // Take field
    pub fn take_enqueued_vaas(&mut self) -> ::protobuf::RepeatedField<ChainGovernorStatus_EnqueuedVAA> {
        ::std::mem::replace(&mut self.enqueued_vaas, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChainGovernorStatus_Emitter {
    fn is_initialized(&self) -> bool {
        for v in &self.enqueued_vaas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.emitter_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_enqueued_vaas = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.enqueued_vaas)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.emitter_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.emitter_address);
        }
        if self.total_enqueued_vaas != 0 {
            my_size += ::protobuf::rt::value_size(2, self.total_enqueued_vaas, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.enqueued_vaas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.emitter_address.is_empty() {
            os.write_string(1, &self.emitter_address)?;
        }
        if self.total_enqueued_vaas != 0 {
            os.write_uint64(2, self.total_enqueued_vaas)?;
        }
        for v in &self.enqueued_vaas {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainGovernorStatus_Emitter {
        ChainGovernorStatus_Emitter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "emitter_address",
                |m: &ChainGovernorStatus_Emitter| { &m.emitter_address },
                |m: &mut ChainGovernorStatus_Emitter| { &mut m.emitter_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_enqueued_vaas",
                |m: &ChainGovernorStatus_Emitter| { &m.total_enqueued_vaas },
                |m: &mut ChainGovernorStatus_Emitter| { &mut m.total_enqueued_vaas },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChainGovernorStatus_EnqueuedVAA>>(
                "enqueued_vaas",
                |m: &ChainGovernorStatus_Emitter| { &m.enqueued_vaas },
                |m: &mut ChainGovernorStatus_Emitter| { &mut m.enqueued_vaas },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChainGovernorStatus_Emitter>(
                "ChainGovernorStatus.Emitter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChainGovernorStatus_Emitter {
        static instance: ::protobuf::rt::LazyV2<ChainGovernorStatus_Emitter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChainGovernorStatus_Emitter::new)
    }
}

impl ::protobuf::Clear for ChainGovernorStatus_Emitter {
    fn clear(&mut self) {
        self.emitter_address.clear();
        self.total_enqueued_vaas = 0;
        self.enqueued_vaas.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainGovernorStatus_Emitter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainGovernorStatus_Emitter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChainGovernorStatus_Chain {
    // message fields
    pub chain_id: u32,
    pub remaining_available_notional: u64,
    pub emitters: ::protobuf::RepeatedField<ChainGovernorStatus_Emitter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainGovernorStatus_Chain {
    fn default() -> &'a ChainGovernorStatus_Chain {
        <ChainGovernorStatus_Chain as ::protobuf::Message>::default_instance()
    }
}

impl ChainGovernorStatus_Chain {
    pub fn new() -> ChainGovernorStatus_Chain {
        ::std::default::Default::default()
    }

    // uint32 chain_id = 1;


    pub fn get_chain_id(&self) -> u32 {
        self.chain_id
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: u32) {
        self.chain_id = v;
    }

    // uint64 remaining_available_notional = 2;


    pub fn get_remaining_available_notional(&self) -> u64 {
        self.remaining_available_notional
    }
    pub fn clear_remaining_available_notional(&mut self) {
        self.remaining_available_notional = 0;
    }

    // Param is passed by value, moved
    pub fn set_remaining_available_notional(&mut self, v: u64) {
        self.remaining_available_notional = v;
    }

    // repeated .gossip.v1.ChainGovernorStatus.Emitter emitters = 3;


    pub fn get_emitters(&self) -> &[ChainGovernorStatus_Emitter] {
        &self.emitters
    }
    pub fn clear_emitters(&mut self) {
        self.emitters.clear();
    }

    // Param is passed by value, moved
    pub fn set_emitters(&mut self, v: ::protobuf::RepeatedField<ChainGovernorStatus_Emitter>) {
        self.emitters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_emitters(&mut self) -> &mut ::protobuf::RepeatedField<ChainGovernorStatus_Emitter> {
        &mut self.emitters
    }

    // Take field
    pub fn take_emitters(&mut self) -> ::protobuf::RepeatedField<ChainGovernorStatus_Emitter> {
        ::std::mem::replace(&mut self.emitters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChainGovernorStatus_Chain {
    fn is_initialized(&self) -> bool {
        for v in &self.emitters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.chain_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.remaining_available_notional = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.emitters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chain_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chain_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remaining_available_notional != 0 {
            my_size += ::protobuf::rt::value_size(2, self.remaining_available_notional, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.emitters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chain_id != 0 {
            os.write_uint32(1, self.chain_id)?;
        }
        if self.remaining_available_notional != 0 {
            os.write_uint64(2, self.remaining_available_notional)?;
        }
        for v in &self.emitters {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainGovernorStatus_Chain {
        ChainGovernorStatus_Chain::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "chain_id",
                |m: &ChainGovernorStatus_Chain| { &m.chain_id },
                |m: &mut ChainGovernorStatus_Chain| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "remaining_available_notional",
                |m: &ChainGovernorStatus_Chain| { &m.remaining_available_notional },
                |m: &mut ChainGovernorStatus_Chain| { &mut m.remaining_available_notional },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChainGovernorStatus_Emitter>>(
                "emitters",
                |m: &ChainGovernorStatus_Chain| { &m.emitters },
                |m: &mut ChainGovernorStatus_Chain| { &mut m.emitters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChainGovernorStatus_Chain>(
                "ChainGovernorStatus.Chain",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChainGovernorStatus_Chain {
        static instance: ::protobuf::rt::LazyV2<ChainGovernorStatus_Chain> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChainGovernorStatus_Chain::new)
    }
}

impl ::protobuf::Clear for ChainGovernorStatus_Chain {
    fn clear(&mut self) {
        self.chain_id = 0;
        self.remaining_available_notional = 0;
        self.emitters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainGovernorStatus_Chain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainGovernorStatus_Chain {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16gossip/v1/gossip.proto\x12\tgossip.v1\"\x86\x06\n\rGossipMessage\
    \x12M\n\x12signed_observation\x18\x02\x20\x01(\x0b2\x1c.gossip.v1.Signed\
    ObservationH\0R\x11signedObservation\x12G\n\x10signed_heartbeat\x18\x03\
    \x20\x01(\x0b2\x1a.gossip.v1.SignedHeartbeatH\0R\x0fsignedHeartbeat\x12U\
    \n\x16signed_vaa_with_quorum\x18\x04\x20\x01(\x0b2\x1e.gossip.v1.SignedV\
    AAWithQuorumH\0R\x13signedVaaWithQuorum\x12c\n\x1asigned_observation_req\
    uest\x18\x05\x20\x01(\x0b2#.gossip.v1.SignedObservationRequestH\0R\x18si\
    gnedObservationRequest\x12]\n\x18signed_batch_observation\x18\x06\x20\
    \x01(\x0b2!.gossip.v1.SignedBatchObservationH\0R\x16signedBatchObservati\
    on\x12e\n\x1csigned_batch_vaa_with_quorum\x18\x07\x20\x01(\x0b2#.gossip.\
    v1.SignedBatchVAAWithQuorumH\0R\x18signedBatchVaaWithQuorum\x12g\n\x1csi\
    gned_chain_governor_config\x18\x08\x20\x01(\x0b2$.gossip.v1.SignedChainG\
    overnorConfigH\0R\x19signedChainGovernorConfig\x12g\n\x1csigned_chain_go\
    vernor_status\x18\t\x20\x01(\x0b2$.gossip.v1.SignedChainGovernorStatusH\
    \0R\x19signedChainGovernorStatusB\t\n\x07message\"r\n\x0fSignedHeartbeat\
    \x12\x1c\n\theartbeat\x18\x01\x20\x01(\x0cR\theartbeat\x12\x1c\n\tsignat\
    ure\x18\x02\x20\x01(\x0cR\tsignature\x12#\n\rguardian_addr\x18\x03\x20\
    \x01(\x0cR\x0cguardianAddr\"\xbb\x03\n\tHeartbeat\x12\x1b\n\tnode_name\
    \x18\x01\x20\x01(\tR\x08nodeName\x12\x18\n\x07counter\x18\x02\x20\x01(\
    \x03R\x07counter\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\x03R\ttimestamp\
    \x128\n\x08networks\x18\x04\x20\x03(\x0b2\x1c.gossip.v1.Heartbeat.Networ\
    kR\x08networks\x12\x18\n\x07version\x18\x05\x20\x01(\tR\x07version\x12#\
    \n\rguardian_addr\x18\x06\x20\x01(\tR\x0cguardianAddr\x12%\n\x0eboot_tim\
    estamp\x18\x07\x20\x01(\x03R\rbootTimestamp\x12\x1a\n\x08features\x18\
    \x08\x20\x03(\tR\x08features\x12\x1e\n\x0bp2p_node_id\x18\t\x20\x01(\x0c\
    R\tp2pNodeId\x1a}\n\x07Network\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\
    \x12\x16\n\x06height\x18\x02\x20\x01(\x03R\x06height\x12)\n\x10contract_\
    address\x18\x03\x20\x01(\tR\x0fcontractAddress\x12\x1f\n\x0berror_count\
    \x18\x04\x20\x01(\x04R\nerrorCount\"\x91\x01\n\x11SignedObservation\x12\
    \x12\n\x04addr\x18\x01\x20\x01(\x0cR\x04addr\x12\x12\n\x04hash\x18\x02\
    \x20\x01(\x0cR\x04hash\x12\x1c\n\tsignature\x18\x03\x20\x01(\x0cR\tsigna\
    ture\x12\x17\n\x07tx_hash\x18\x04\x20\x01(\x0cR\x06txHash\x12\x1d\n\nmes\
    sage_id\x18\x05\x20\x01(\tR\tmessageId\"'\n\x13SignedVAAWithQuorum\x12\
    \x10\n\x03vaa\x18\x01\x20\x01(\x0cR\x03vaa\"\x8e\x01\n\x18SignedObservat\
    ionRequest\x12/\n\x13observation_request\x18\x01\x20\x01(\x0cR\x12observ\
    ationRequest\x12\x1c\n\tsignature\x18\x02\x20\x01(\x0cR\tsignature\x12#\
    \n\rguardian_addr\x18\x03\x20\x01(\x0cR\x0cguardianAddr\"H\n\x12Observat\
    ionRequest\x12\x19\n\x08chain_id\x18\x01\x20\x01(\rR\x07chainId\x12\x17\
    \n\x07tx_hash\x18\x02\x20\x01(\x0cR\x06txHash\"\xbf\x01\n\x16SignedBatch\
    Observation\x12\x12\n\x04addr\x18\x01\x20\x01(\x0cR\x04addr\x12\x12\n\
    \x04hash\x18\x02\x20\x01(\x0cR\x04hash\x12\x1c\n\tsignature\x18\x03\x20\
    \x01(\x0cR\tsignature\x12\x13\n\x05tx_id\x18\x04\x20\x01(\x0cR\x04txId\
    \x12\x19\n\x08chain_id\x18\x05\x20\x01(\rR\x07chainId\x12\x14\n\x05nonce\
    \x18\x06\x20\x01(\rR\x05nonce\x12\x19\n\x08batch_id\x18\x07\x20\x01(\tR\
    \x07batchId\"\x98\x01\n\x18SignedBatchVAAWithQuorum\x12\x1b\n\tbatch_vaa\
    \x18\x01\x20\x01(\x0cR\x08batchVaa\x12\x19\n\x08chain_id\x18\x02\x20\x01\
    (\rR\x07chainId\x12\x13\n\x05tx_id\x18\x03\x20\x01(\x0cR\x04txId\x12\x14\
    \n\x05nonce\x18\x04\x20\x01(\rR\x05nonce\x12\x19\n\x08batch_id\x18\x05\
    \x20\x01(\tR\x07batchId\"v\n\x19SignedChainGovernorConfig\x12\x16\n\x06c\
    onfig\x18\x01\x20\x01(\x0cR\x06config\x12\x1c\n\tsignature\x18\x02\x20\
    \x01(\x0cR\tsignature\x12#\n\rguardian_addr\x18\x03\x20\x01(\x0cR\x0cgua\
    rdianAddr\"\xd1\x03\n\x13ChainGovernorConfig\x12\x1b\n\tnode_name\x18\
    \x01\x20\x01(\tR\x08nodeName\x12\x18\n\x07counter\x18\x02\x20\x01(\x03R\
    \x07counter\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\x03R\ttimestamp\x12<\n\
    \x06chains\x18\x04\x20\x03(\x0b2$.gossip.v1.ChainGovernorConfig.ChainR\
    \x06chains\x12<\n\x06tokens\x18\x05\x20\x03(\x0b2$.gossip.v1.ChainGovern\
    orConfig.TokenR\x06tokens\x1a{\n\x05Chain\x12\x19\n\x08chain_id\x18\x01\
    \x20\x01(\rR\x07chainId\x12%\n\x0enotional_limit\x18\x02\x20\x01(\x04R\r\
    notionalLimit\x120\n\x14big_transaction_size\x18\x03\x20\x01(\x04R\x12bi\
    gTransactionSize\x1al\n\x05Token\x12&\n\x0forigin_chain_id\x18\x01\x20\
    \x01(\rR\roriginChainId\x12%\n\x0eorigin_address\x18\x02\x20\x01(\tR\ror\
    iginAddress\x12\x14\n\x05price\x18\x03\x20\x01(\x02R\x05price\"v\n\x19Si\
    gnedChainGovernorStatus\x12\x16\n\x06status\x18\x01\x20\x01(\x0cR\x06sta\
    tus\x12\x1c\n\tsignature\x18\x02\x20\x01(\x0cR\tsignature\x12#\n\rguardi\
    an_addr\x18\x03\x20\x01(\x0cR\x0cguardianAddr\"\x98\x05\n\x13ChainGovern\
    orStatus\x12\x1b\n\tnode_name\x18\x01\x20\x01(\tR\x08nodeName\x12\x18\n\
    \x07counter\x18\x02\x20\x01(\x03R\x07counter\x12\x1c\n\ttimestamp\x18\
    \x03\x20\x01(\x03R\ttimestamp\x12<\n\x06chains\x18\x04\x20\x03(\x0b2$.go\
    ssip.v1.ChainGovernorStatus.ChainR\x06chains\x1a\x8c\x01\n\x0bEnqueuedVA\
    A\x12\x1a\n\x08sequence\x18\x01\x20\x01(\x04R\x08sequence\x12!\n\x0crele\
    ase_time\x18\x02\x20\x01(\rR\x0breleaseTime\x12%\n\x0enotional_value\x18\
    \x03\x20\x01(\x04R\rnotionalValue\x12\x17\n\x07tx_hash\x18\x04\x20\x01(\
    \tR\x06txHash\x1a\xb3\x01\n\x07Emitter\x12'\n\x0femitter_address\x18\x01\
    \x20\x01(\tR\x0eemitterAddress\x12.\n\x13total_enqueued_vaas\x18\x02\x20\
    \x01(\x04R\x11totalEnqueuedVaas\x12O\n\renqueued_vaas\x18\x03\x20\x03(\
    \x0b2*.gossip.v1.ChainGovernorStatus.EnqueuedVAAR\x0cenqueuedVaas\x1a\
    \xa8\x01\n\x05Chain\x12\x19\n\x08chain_id\x18\x01\x20\x01(\rR\x07chainId\
    \x12@\n\x1cremaining_available_notional\x18\x02\x20\x01(\x04R\x1aremaini\
    ngAvailableNotional\x12B\n\x08emitters\x18\x03\x20\x03(\x0b2&.gossip.v1.\
    ChainGovernorStatus.EmitterR\x08emittersBAZ?github.com/certusone/wormhol\
    e/node/pkg/proto/gossip/v1;gossipv1b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
