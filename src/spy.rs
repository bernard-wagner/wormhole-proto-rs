// This file is generated by rust-protobuf 2.18.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `spy/v1/spy.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_2;

#[derive(PartialEq,Clone,Default)]
pub struct EmitterFilter {
    // message fields
    pub chain_id: super::publicrpc::ChainID,
    pub emitter_address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EmitterFilter {
    fn default() -> &'a EmitterFilter {
        <EmitterFilter as ::protobuf::Message>::default_instance()
    }
}

impl EmitterFilter {
    pub fn new() -> EmitterFilter {
        ::std::default::Default::default()
    }

    // .publicrpc.v1.ChainID chain_id = 1;


    pub fn get_chain_id(&self) -> super::publicrpc::ChainID {
        self.chain_id
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id = super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: super::publicrpc::ChainID) {
        self.chain_id = v;
    }

    // string emitter_address = 2;


    pub fn get_emitter_address(&self) -> &str {
        &self.emitter_address
    }
    pub fn clear_emitter_address(&mut self) {
        self.emitter_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_emitter_address(&mut self, v: ::std::string::String) {
        self.emitter_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emitter_address(&mut self) -> &mut ::std::string::String {
        &mut self.emitter_address
    }

    // Take field
    pub fn take_emitter_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.emitter_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EmitterFilter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.chain_id, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.emitter_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chain_id != super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.chain_id);
        }
        if !self.emitter_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.emitter_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chain_id != super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.chain_id))?;
        }
        if !self.emitter_address.is_empty() {
            os.write_string(2, &self.emitter_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EmitterFilter {
        EmitterFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::publicrpc::ChainID>>(
                "chain_id",
                |m: &EmitterFilter| { &m.chain_id },
                |m: &mut EmitterFilter| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "emitter_address",
                |m: &EmitterFilter| { &m.emitter_address },
                |m: &mut EmitterFilter| { &mut m.emitter_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EmitterFilter>(
                "EmitterFilter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EmitterFilter {
        static instance: ::protobuf::rt::LazyV2<EmitterFilter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EmitterFilter::new)
    }
}

impl ::protobuf::Clear for EmitterFilter {
    fn clear(&mut self) {
        self.chain_id = super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED;
        self.emitter_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EmitterFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmitterFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchFilter {
    // message fields
    pub chain_id: super::publicrpc::ChainID,
    pub tx_id: ::std::vec::Vec<u8>,
    pub nonce: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchFilter {
    fn default() -> &'a BatchFilter {
        <BatchFilter as ::protobuf::Message>::default_instance()
    }
}

impl BatchFilter {
    pub fn new() -> BatchFilter {
        ::std::default::Default::default()
    }

    // .publicrpc.v1.ChainID chain_id = 1;


    pub fn get_chain_id(&self) -> super::publicrpc::ChainID {
        self.chain_id
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id = super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: super::publicrpc::ChainID) {
        self.chain_id = v;
    }

    // bytes tx_id = 2;


    pub fn get_tx_id(&self) -> &[u8] {
        &self.tx_id
    }
    pub fn clear_tx_id(&mut self) {
        self.tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.tx_id
    }

    // Take field
    pub fn take_tx_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.tx_id, ::std::vec::Vec::new())
    }

    // uint32 nonce = 3;


    pub fn get_nonce(&self) -> u32 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u32) {
        self.nonce = v;
    }
}

impl ::protobuf::Message for BatchFilter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.chain_id, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.tx_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nonce = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chain_id != super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.chain_id);
        }
        if !self.tx_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.tx_id);
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(3, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chain_id != super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.chain_id))?;
        }
        if !self.tx_id.is_empty() {
            os.write_bytes(2, &self.tx_id)?;
        }
        if self.nonce != 0 {
            os.write_uint32(3, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchFilter {
        BatchFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::publicrpc::ChainID>>(
                "chain_id",
                |m: &BatchFilter| { &m.chain_id },
                |m: &mut BatchFilter| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tx_id",
                |m: &BatchFilter| { &m.tx_id },
                |m: &mut BatchFilter| { &mut m.tx_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nonce",
                |m: &BatchFilter| { &m.nonce },
                |m: &mut BatchFilter| { &mut m.nonce },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchFilter>(
                "BatchFilter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchFilter {
        static instance: ::protobuf::rt::LazyV2<BatchFilter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchFilter::new)
    }
}

impl ::protobuf::Clear for BatchFilter {
    fn clear(&mut self) {
        self.chain_id = super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED;
        self.tx_id.clear();
        self.nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchTransactionFilter {
    // message fields
    pub chain_id: super::publicrpc::ChainID,
    pub tx_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchTransactionFilter {
    fn default() -> &'a BatchTransactionFilter {
        <BatchTransactionFilter as ::protobuf::Message>::default_instance()
    }
}

impl BatchTransactionFilter {
    pub fn new() -> BatchTransactionFilter {
        ::std::default::Default::default()
    }

    // .publicrpc.v1.ChainID chain_id = 1;


    pub fn get_chain_id(&self) -> super::publicrpc::ChainID {
        self.chain_id
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id = super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: super::publicrpc::ChainID) {
        self.chain_id = v;
    }

    // bytes tx_id = 2;


    pub fn get_tx_id(&self) -> &[u8] {
        &self.tx_id
    }
    pub fn clear_tx_id(&mut self) {
        self.tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.tx_id
    }

    // Take field
    pub fn take_tx_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.tx_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BatchTransactionFilter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.chain_id, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.tx_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chain_id != super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.chain_id);
        }
        if !self.tx_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.tx_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chain_id != super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.chain_id))?;
        }
        if !self.tx_id.is_empty() {
            os.write_bytes(2, &self.tx_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchTransactionFilter {
        BatchTransactionFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::publicrpc::ChainID>>(
                "chain_id",
                |m: &BatchTransactionFilter| { &m.chain_id },
                |m: &mut BatchTransactionFilter| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tx_id",
                |m: &BatchTransactionFilter| { &m.tx_id },
                |m: &mut BatchTransactionFilter| { &mut m.tx_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchTransactionFilter>(
                "BatchTransactionFilter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchTransactionFilter {
        static instance: ::protobuf::rt::LazyV2<BatchTransactionFilter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchTransactionFilter::new)
    }
}

impl ::protobuf::Clear for BatchTransactionFilter {
    fn clear(&mut self) {
        self.chain_id = super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED;
        self.tx_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchTransactionFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchTransactionFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FilterEntry {
    // message oneof groups
    pub filter: ::std::option::Option<FilterEntry_oneof_filter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilterEntry {
    fn default() -> &'a FilterEntry {
        <FilterEntry as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum FilterEntry_oneof_filter {
    emitter_filter(EmitterFilter),
    batch_filter(BatchFilter),
    batch_transaction_filter(BatchTransactionFilter),
}

impl FilterEntry {
    pub fn new() -> FilterEntry {
        ::std::default::Default::default()
    }

    // .spy.v1.EmitterFilter emitter_filter = 1;


    pub fn get_emitter_filter(&self) -> &EmitterFilter {
        match self.filter {
            ::std::option::Option::Some(FilterEntry_oneof_filter::emitter_filter(ref v)) => v,
            _ => <EmitterFilter as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_emitter_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_emitter_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(FilterEntry_oneof_filter::emitter_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_emitter_filter(&mut self, v: EmitterFilter) {
        self.filter = ::std::option::Option::Some(FilterEntry_oneof_filter::emitter_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_emitter_filter(&mut self) -> &mut EmitterFilter {
        if let ::std::option::Option::Some(FilterEntry_oneof_filter::emitter_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(FilterEntry_oneof_filter::emitter_filter(EmitterFilter::new()));
        }
        match self.filter {
            ::std::option::Option::Some(FilterEntry_oneof_filter::emitter_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_emitter_filter(&mut self) -> EmitterFilter {
        if self.has_emitter_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(FilterEntry_oneof_filter::emitter_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            EmitterFilter::new()
        }
    }

    // .spy.v1.BatchFilter batch_filter = 2;


    pub fn get_batch_filter(&self) -> &BatchFilter {
        match self.filter {
            ::std::option::Option::Some(FilterEntry_oneof_filter::batch_filter(ref v)) => v,
            _ => <BatchFilter as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_batch_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_batch_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(FilterEntry_oneof_filter::batch_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_batch_filter(&mut self, v: BatchFilter) {
        self.filter = ::std::option::Option::Some(FilterEntry_oneof_filter::batch_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_batch_filter(&mut self) -> &mut BatchFilter {
        if let ::std::option::Option::Some(FilterEntry_oneof_filter::batch_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(FilterEntry_oneof_filter::batch_filter(BatchFilter::new()));
        }
        match self.filter {
            ::std::option::Option::Some(FilterEntry_oneof_filter::batch_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_batch_filter(&mut self) -> BatchFilter {
        if self.has_batch_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(FilterEntry_oneof_filter::batch_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            BatchFilter::new()
        }
    }

    // .spy.v1.BatchTransactionFilter batch_transaction_filter = 3;


    pub fn get_batch_transaction_filter(&self) -> &BatchTransactionFilter {
        match self.filter {
            ::std::option::Option::Some(FilterEntry_oneof_filter::batch_transaction_filter(ref v)) => v,
            _ => <BatchTransactionFilter as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_batch_transaction_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_batch_transaction_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(FilterEntry_oneof_filter::batch_transaction_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_batch_transaction_filter(&mut self, v: BatchTransactionFilter) {
        self.filter = ::std::option::Option::Some(FilterEntry_oneof_filter::batch_transaction_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_batch_transaction_filter(&mut self) -> &mut BatchTransactionFilter {
        if let ::std::option::Option::Some(FilterEntry_oneof_filter::batch_transaction_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(FilterEntry_oneof_filter::batch_transaction_filter(BatchTransactionFilter::new()));
        }
        match self.filter {
            ::std::option::Option::Some(FilterEntry_oneof_filter::batch_transaction_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_batch_transaction_filter(&mut self) -> BatchTransactionFilter {
        if self.has_batch_transaction_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(FilterEntry_oneof_filter::batch_transaction_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            BatchTransactionFilter::new()
        }
    }
}

impl ::protobuf::Message for FilterEntry {
    fn is_initialized(&self) -> bool {
        if let Some(FilterEntry_oneof_filter::emitter_filter(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FilterEntry_oneof_filter::batch_filter(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FilterEntry_oneof_filter::batch_transaction_filter(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(FilterEntry_oneof_filter::emitter_filter(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(FilterEntry_oneof_filter::batch_filter(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(FilterEntry_oneof_filter::batch_transaction_filter(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &FilterEntry_oneof_filter::emitter_filter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FilterEntry_oneof_filter::batch_filter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FilterEntry_oneof_filter::batch_transaction_filter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &FilterEntry_oneof_filter::emitter_filter(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FilterEntry_oneof_filter::batch_filter(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FilterEntry_oneof_filter::batch_transaction_filter(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilterEntry {
        FilterEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EmitterFilter>(
                "emitter_filter",
                FilterEntry::has_emitter_filter,
                FilterEntry::get_emitter_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BatchFilter>(
                "batch_filter",
                FilterEntry::has_batch_filter,
                FilterEntry::get_batch_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BatchTransactionFilter>(
                "batch_transaction_filter",
                FilterEntry::has_batch_transaction_filter,
                FilterEntry::get_batch_transaction_filter,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FilterEntry>(
                "FilterEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FilterEntry {
        static instance: ::protobuf::rt::LazyV2<FilterEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FilterEntry::new)
    }
}

impl ::protobuf::Clear for FilterEntry {
    fn clear(&mut self) {
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilterEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilterEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeSignedVAARequest {
    // message fields
    pub filters: ::protobuf::RepeatedField<FilterEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeSignedVAARequest {
    fn default() -> &'a SubscribeSignedVAARequest {
        <SubscribeSignedVAARequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeSignedVAARequest {
    pub fn new() -> SubscribeSignedVAARequest {
        ::std::default::Default::default()
    }

    // repeated .spy.v1.FilterEntry filters = 1;


    pub fn get_filters(&self) -> &[FilterEntry] {
        &self.filters
    }
    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: ::protobuf::RepeatedField<FilterEntry>) {
        self.filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filters(&mut self) -> &mut ::protobuf::RepeatedField<FilterEntry> {
        &mut self.filters
    }

    // Take field
    pub fn take_filters(&mut self) -> ::protobuf::RepeatedField<FilterEntry> {
        ::std::mem::replace(&mut self.filters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SubscribeSignedVAARequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.filters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.filters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeSignedVAARequest {
        SubscribeSignedVAARequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilterEntry>>(
                "filters",
                |m: &SubscribeSignedVAARequest| { &m.filters },
                |m: &mut SubscribeSignedVAARequest| { &mut m.filters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeSignedVAARequest>(
                "SubscribeSignedVAARequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeSignedVAARequest {
        static instance: ::protobuf::rt::LazyV2<SubscribeSignedVAARequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeSignedVAARequest::new)
    }
}

impl ::protobuf::Clear for SubscribeSignedVAARequest {
    fn clear(&mut self) {
        self.filters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeSignedVAARequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeSignedVAARequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeSignedVAAByTypeRequest {
    // message fields
    pub filters: ::protobuf::RepeatedField<FilterEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeSignedVAAByTypeRequest {
    fn default() -> &'a SubscribeSignedVAAByTypeRequest {
        <SubscribeSignedVAAByTypeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeSignedVAAByTypeRequest {
    pub fn new() -> SubscribeSignedVAAByTypeRequest {
        ::std::default::Default::default()
    }

    // repeated .spy.v1.FilterEntry filters = 1;


    pub fn get_filters(&self) -> &[FilterEntry] {
        &self.filters
    }
    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: ::protobuf::RepeatedField<FilterEntry>) {
        self.filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filters(&mut self) -> &mut ::protobuf::RepeatedField<FilterEntry> {
        &mut self.filters
    }

    // Take field
    pub fn take_filters(&mut self) -> ::protobuf::RepeatedField<FilterEntry> {
        ::std::mem::replace(&mut self.filters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SubscribeSignedVAAByTypeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.filters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.filters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.filters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeSignedVAAByTypeRequest {
        SubscribeSignedVAAByTypeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilterEntry>>(
                "filters",
                |m: &SubscribeSignedVAAByTypeRequest| { &m.filters },
                |m: &mut SubscribeSignedVAAByTypeRequest| { &mut m.filters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeSignedVAAByTypeRequest>(
                "SubscribeSignedVAAByTypeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeSignedVAAByTypeRequest {
        static instance: ::protobuf::rt::LazyV2<SubscribeSignedVAAByTypeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeSignedVAAByTypeRequest::new)
    }
}

impl ::protobuf::Clear for SubscribeSignedVAAByTypeRequest {
    fn clear(&mut self) {
        self.filters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeSignedVAAByTypeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeSignedVAAByTypeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeSignedVAAResponse {
    // message fields
    pub vaa_bytes: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeSignedVAAResponse {
    fn default() -> &'a SubscribeSignedVAAResponse {
        <SubscribeSignedVAAResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeSignedVAAResponse {
    pub fn new() -> SubscribeSignedVAAResponse {
        ::std::default::Default::default()
    }

    // bytes vaa_bytes = 1;


    pub fn get_vaa_bytes(&self) -> &[u8] {
        &self.vaa_bytes
    }
    pub fn clear_vaa_bytes(&mut self) {
        self.vaa_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_vaa_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.vaa_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vaa_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.vaa_bytes
    }

    // Take field
    pub fn take_vaa_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.vaa_bytes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SubscribeSignedVAAResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.vaa_bytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.vaa_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.vaa_bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.vaa_bytes.is_empty() {
            os.write_bytes(1, &self.vaa_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeSignedVAAResponse {
        SubscribeSignedVAAResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "vaa_bytes",
                |m: &SubscribeSignedVAAResponse| { &m.vaa_bytes },
                |m: &mut SubscribeSignedVAAResponse| { &mut m.vaa_bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeSignedVAAResponse>(
                "SubscribeSignedVAAResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeSignedVAAResponse {
        static instance: ::protobuf::rt::LazyV2<SubscribeSignedVAAResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeSignedVAAResponse::new)
    }
}

impl ::protobuf::Clear for SubscribeSignedVAAResponse {
    fn clear(&mut self) {
        self.vaa_bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeSignedVAAResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeSignedVAAResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeSignedVAAByTypeResponse {
    // message oneof groups
    pub vaa_type: ::std::option::Option<SubscribeSignedVAAByTypeResponse_oneof_vaa_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeSignedVAAByTypeResponse {
    fn default() -> &'a SubscribeSignedVAAByTypeResponse {
        <SubscribeSignedVAAByTypeResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum SubscribeSignedVAAByTypeResponse_oneof_vaa_type {
    signed_vaa(super::gossip::SignedVAAWithQuorum),
    signed_batch_vaa(super::gossip::SignedBatchVAAWithQuorum),
}

impl SubscribeSignedVAAByTypeResponse {
    pub fn new() -> SubscribeSignedVAAByTypeResponse {
        ::std::default::Default::default()
    }

    // .gossip.v1.SignedVAAWithQuorum signed_vaa = 1;


    pub fn get_signed_vaa(&self) -> &super::gossip::SignedVAAWithQuorum {
        match self.vaa_type {
            ::std::option::Option::Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_vaa(ref v)) => v,
            _ => <super::gossip::SignedVAAWithQuorum as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_signed_vaa(&mut self) {
        self.vaa_type = ::std::option::Option::None;
    }

    pub fn has_signed_vaa(&self) -> bool {
        match self.vaa_type {
            ::std::option::Option::Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_vaa(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_vaa(&mut self, v: super::gossip::SignedVAAWithQuorum) {
        self.vaa_type = ::std::option::Option::Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_vaa(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_vaa(&mut self) -> &mut super::gossip::SignedVAAWithQuorum {
        if let ::std::option::Option::Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_vaa(_)) = self.vaa_type {
        } else {
            self.vaa_type = ::std::option::Option::Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_vaa(super::gossip::SignedVAAWithQuorum::new()));
        }
        match self.vaa_type {
            ::std::option::Option::Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_vaa(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_vaa(&mut self) -> super::gossip::SignedVAAWithQuorum {
        if self.has_signed_vaa() {
            match self.vaa_type.take() {
                ::std::option::Option::Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_vaa(v)) => v,
                _ => panic!(),
            }
        } else {
            super::gossip::SignedVAAWithQuorum::new()
        }
    }

    // .gossip.v1.SignedBatchVAAWithQuorum signed_batch_vaa = 2;


    pub fn get_signed_batch_vaa(&self) -> &super::gossip::SignedBatchVAAWithQuorum {
        match self.vaa_type {
            ::std::option::Option::Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_batch_vaa(ref v)) => v,
            _ => <super::gossip::SignedBatchVAAWithQuorum as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_signed_batch_vaa(&mut self) {
        self.vaa_type = ::std::option::Option::None;
    }

    pub fn has_signed_batch_vaa(&self) -> bool {
        match self.vaa_type {
            ::std::option::Option::Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_batch_vaa(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_batch_vaa(&mut self, v: super::gossip::SignedBatchVAAWithQuorum) {
        self.vaa_type = ::std::option::Option::Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_batch_vaa(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_batch_vaa(&mut self) -> &mut super::gossip::SignedBatchVAAWithQuorum {
        if let ::std::option::Option::Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_batch_vaa(_)) = self.vaa_type {
        } else {
            self.vaa_type = ::std::option::Option::Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_batch_vaa(super::gossip::SignedBatchVAAWithQuorum::new()));
        }
        match self.vaa_type {
            ::std::option::Option::Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_batch_vaa(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_batch_vaa(&mut self) -> super::gossip::SignedBatchVAAWithQuorum {
        if self.has_signed_batch_vaa() {
            match self.vaa_type.take() {
                ::std::option::Option::Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_batch_vaa(v)) => v,
                _ => panic!(),
            }
        } else {
            super::gossip::SignedBatchVAAWithQuorum::new()
        }
    }
}

impl ::protobuf::Message for SubscribeSignedVAAByTypeResponse {
    fn is_initialized(&self) -> bool {
        if let Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_vaa(ref v)) = self.vaa_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_batch_vaa(ref v)) = self.vaa_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.vaa_type = ::std::option::Option::Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_vaa(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.vaa_type = ::std::option::Option::Some(SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_batch_vaa(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.vaa_type {
            match v {
                &SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_vaa(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_batch_vaa(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.vaa_type {
            match v {
                &SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_vaa(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SubscribeSignedVAAByTypeResponse_oneof_vaa_type::signed_batch_vaa(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeSignedVAAByTypeResponse {
        SubscribeSignedVAAByTypeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::gossip::SignedVAAWithQuorum>(
                "signed_vaa",
                SubscribeSignedVAAByTypeResponse::has_signed_vaa,
                SubscribeSignedVAAByTypeResponse::get_signed_vaa,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::gossip::SignedBatchVAAWithQuorum>(
                "signed_batch_vaa",
                SubscribeSignedVAAByTypeResponse::has_signed_batch_vaa,
                SubscribeSignedVAAByTypeResponse::get_signed_batch_vaa,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeSignedVAAByTypeResponse>(
                "SubscribeSignedVAAByTypeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeSignedVAAByTypeResponse {
        static instance: ::protobuf::rt::LazyV2<SubscribeSignedVAAByTypeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeSignedVAAByTypeResponse::new)
    }
}

impl ::protobuf::Clear for SubscribeSignedVAAByTypeResponse {
    fn clear(&mut self) {
        self.vaa_type = ::std::option::Option::None;
        self.vaa_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeSignedVAAByTypeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeSignedVAAByTypeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10spy/v1/spy.proto\x12\x06spy.v1\x1a\x1cgoogle/api/annotations.proto\
    \x1a\x16gossip/v1/gossip.proto\x1a\x1cpublicrpc/v1/publicrpc.proto\"j\n\
    \rEmitterFilter\x120\n\x08chain_id\x18\x01\x20\x01(\x0e2\x15.publicrpc.v\
    1.ChainIDR\x07chainId\x12'\n\x0femitter_address\x18\x02\x20\x01(\tR\x0ee\
    mitterAddress\"j\n\x0bBatchFilter\x120\n\x08chain_id\x18\x01\x20\x01(\
    \x0e2\x15.publicrpc.v1.ChainIDR\x07chainId\x12\x13\n\x05tx_id\x18\x02\
    \x20\x01(\x0cR\x04txId\x12\x14\n\x05nonce\x18\x03\x20\x01(\rR\x05nonce\"\
    _\n\x16BatchTransactionFilter\x120\n\x08chain_id\x18\x01\x20\x01(\x0e2\
    \x15.publicrpc.v1.ChainIDR\x07chainId\x12\x13\n\x05tx_id\x18\x02\x20\x01\
    (\x0cR\x04txId\"\xed\x01\n\x0bFilterEntry\x12>\n\x0eemitter_filter\x18\
    \x01\x20\x01(\x0b2\x15.spy.v1.EmitterFilterH\0R\remitterFilter\x128\n\
    \x0cbatch_filter\x18\x02\x20\x01(\x0b2\x13.spy.v1.BatchFilterH\0R\x0bbat\
    chFilter\x12Z\n\x18batch_transaction_filter\x18\x03\x20\x01(\x0b2\x1e.sp\
    y.v1.BatchTransactionFilterH\0R\x16batchTransactionFilterB\x08\n\x06filt\
    er\"J\n\x19SubscribeSignedVAARequest\x12-\n\x07filters\x18\x01\x20\x03(\
    \x0b2\x13.spy.v1.FilterEntryR\x07filters\"P\n\x1fSubscribeSignedVAAByTyp\
    eRequest\x12-\n\x07filters\x18\x01\x20\x03(\x0b2\x13.spy.v1.FilterEntryR\
    \x07filters\"9\n\x1aSubscribeSignedVAAResponse\x12\x1b\n\tvaa_bytes\x18\
    \x01\x20\x01(\x0cR\x08vaaBytes\"\xc0\x01\n\x20SubscribeSignedVAAByTypeRe\
    sponse\x12?\n\nsigned_vaa\x18\x01\x20\x01(\x0b2\x1e.gossip.v1.SignedVAAW\
    ithQuorumH\0R\tsignedVaa\x12O\n\x10signed_batch_vaa\x18\x02\x20\x01(\x0b\
    2#.gossip.v1.SignedBatchVAAWithQuorumH\0R\x0esignedBatchVaaB\n\n\x08vaa_\
    type2\xb3\x02\n\rSpyRPCService\x12\x82\x01\n\x12SubscribeSignedVAA\x12!.\
    spy.v1.SubscribeSignedVAARequest\x1a\".spy.v1.SubscribeSignedVAAResponse\
    \"#\x82\xd3\xe4\x93\x02\x1d\"\x18/v1:subscribe_signed_vaa:\x01*0\x01\x12\
    \x9c\x01\n\x18SubscribeSignedVAAByType\x12'.spy.v1.SubscribeSignedVAAByT\
    ypeRequest\x1a(.spy.v1.SubscribeSignedVAAByTypeResponse\"+\x82\xd3\xe4\
    \x93\x02%\"\x20/v1:subscribe_signed_vaa_by_type:\x01*0\x01B;Z9github.com\
    /certusone/wormhole/node/pkg/proto/spy/v1;spyv1b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
