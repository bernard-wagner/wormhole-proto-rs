// This file is generated by rust-protobuf 2.18.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `publicrpc/v1/publicrpc.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_2;

#[derive(PartialEq,Clone,Default)]
pub struct MessageID {
    // message fields
    pub emitter_chain: ChainID,
    pub emitter_address: ::std::string::String,
    pub sequence: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageID {
    fn default() -> &'a MessageID {
        <MessageID as ::protobuf::Message>::default_instance()
    }
}

impl MessageID {
    pub fn new() -> MessageID {
        ::std::default::Default::default()
    }

    // .publicrpc.v1.ChainID emitter_chain = 1;


    pub fn get_emitter_chain(&self) -> ChainID {
        self.emitter_chain
    }
    pub fn clear_emitter_chain(&mut self) {
        self.emitter_chain = ChainID::CHAIN_ID_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_emitter_chain(&mut self, v: ChainID) {
        self.emitter_chain = v;
    }

    // string emitter_address = 2;


    pub fn get_emitter_address(&self) -> &str {
        &self.emitter_address
    }
    pub fn clear_emitter_address(&mut self) {
        self.emitter_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_emitter_address(&mut self, v: ::std::string::String) {
        self.emitter_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emitter_address(&mut self) -> &mut ::std::string::String {
        &mut self.emitter_address
    }

    // Take field
    pub fn take_emitter_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.emitter_address, ::std::string::String::new())
    }

    // uint64 sequence = 3;


    pub fn get_sequence(&self) -> u64 {
        self.sequence
    }
    pub fn clear_sequence(&mut self) {
        self.sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u64) {
        self.sequence = v;
    }
}

impl ::protobuf::Message for MessageID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.emitter_chain, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.emitter_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.emitter_chain != ChainID::CHAIN_ID_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.emitter_chain);
        }
        if !self.emitter_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.emitter_address);
        }
        if self.sequence != 0 {
            my_size += ::protobuf::rt::value_size(3, self.sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.emitter_chain != ChainID::CHAIN_ID_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.emitter_chain))?;
        }
        if !self.emitter_address.is_empty() {
            os.write_string(2, &self.emitter_address)?;
        }
        if self.sequence != 0 {
            os.write_uint64(3, self.sequence)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageID {
        MessageID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ChainID>>(
                "emitter_chain",
                |m: &MessageID| { &m.emitter_chain },
                |m: &mut MessageID| { &mut m.emitter_chain },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "emitter_address",
                |m: &MessageID| { &m.emitter_address },
                |m: &mut MessageID| { &mut m.emitter_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sequence",
                |m: &MessageID| { &m.sequence },
                |m: &mut MessageID| { &mut m.sequence },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageID>(
                "MessageID",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MessageID {
        static instance: ::protobuf::rt::LazyV2<MessageID> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MessageID::new)
    }
}

impl ::protobuf::Clear for MessageID {
    fn clear(&mut self) {
        self.emitter_chain = ChainID::CHAIN_ID_UNSPECIFIED;
        self.emitter_address.clear();
        self.sequence = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageID {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchID {
    // message fields
    pub emitter_chain: ChainID,
    pub tx_id: ::std::vec::Vec<u8>,
    pub nonce: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchID {
    fn default() -> &'a BatchID {
        <BatchID as ::protobuf::Message>::default_instance()
    }
}

impl BatchID {
    pub fn new() -> BatchID {
        ::std::default::Default::default()
    }

    // .publicrpc.v1.ChainID emitter_chain = 1;


    pub fn get_emitter_chain(&self) -> ChainID {
        self.emitter_chain
    }
    pub fn clear_emitter_chain(&mut self) {
        self.emitter_chain = ChainID::CHAIN_ID_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_emitter_chain(&mut self, v: ChainID) {
        self.emitter_chain = v;
    }

    // bytes tx_id = 2;


    pub fn get_tx_id(&self) -> &[u8] {
        &self.tx_id
    }
    pub fn clear_tx_id(&mut self) {
        self.tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.tx_id
    }

    // Take field
    pub fn take_tx_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.tx_id, ::std::vec::Vec::new())
    }

    // uint32 nonce = 3;


    pub fn get_nonce(&self) -> u32 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u32) {
        self.nonce = v;
    }
}

impl ::protobuf::Message for BatchID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.emitter_chain, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.tx_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nonce = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.emitter_chain != ChainID::CHAIN_ID_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.emitter_chain);
        }
        if !self.tx_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.tx_id);
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(3, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.emitter_chain != ChainID::CHAIN_ID_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.emitter_chain))?;
        }
        if !self.tx_id.is_empty() {
            os.write_bytes(2, &self.tx_id)?;
        }
        if self.nonce != 0 {
            os.write_uint32(3, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchID {
        BatchID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ChainID>>(
                "emitter_chain",
                |m: &BatchID| { &m.emitter_chain },
                |m: &mut BatchID| { &mut m.emitter_chain },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tx_id",
                |m: &BatchID| { &m.tx_id },
                |m: &mut BatchID| { &mut m.tx_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nonce",
                |m: &BatchID| { &m.nonce },
                |m: &mut BatchID| { &mut m.nonce },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchID>(
                "BatchID",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchID {
        static instance: ::protobuf::rt::LazyV2<BatchID> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchID::new)
    }
}

impl ::protobuf::Clear for BatchID {
    fn clear(&mut self) {
        self.emitter_chain = ChainID::CHAIN_ID_UNSPECIFIED;
        self.tx_id.clear();
        self.nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchID {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSignedVAARequest {
    // message fields
    pub message_id: ::protobuf::SingularPtrField<MessageID>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSignedVAARequest {
    fn default() -> &'a GetSignedVAARequest {
        <GetSignedVAARequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSignedVAARequest {
    pub fn new() -> GetSignedVAARequest {
        ::std::default::Default::default()
    }

    // .publicrpc.v1.MessageID message_id = 1;


    pub fn get_message_id(&self) -> &MessageID {
        self.message_id.as_ref().unwrap_or_else(|| <MessageID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: MessageID) {
        self.message_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut MessageID {
        if self.message_id.is_none() {
            self.message_id.set_default();
        }
        self.message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_id(&mut self) -> MessageID {
        self.message_id.take().unwrap_or_else(|| MessageID::new())
    }
}

impl ::protobuf::Message for GetSignedVAARequest {
    fn is_initialized(&self) -> bool {
        for v in &self.message_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSignedVAARequest {
        GetSignedVAARequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageID>>(
                "message_id",
                |m: &GetSignedVAARequest| { &m.message_id },
                |m: &mut GetSignedVAARequest| { &mut m.message_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSignedVAARequest>(
                "GetSignedVAARequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSignedVAARequest {
        static instance: ::protobuf::rt::LazyV2<GetSignedVAARequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSignedVAARequest::new)
    }
}

impl ::protobuf::Clear for GetSignedVAARequest {
    fn clear(&mut self) {
        self.message_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSignedVAARequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSignedVAARequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSignedVAAResponse {
    // message fields
    pub vaa_bytes: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSignedVAAResponse {
    fn default() -> &'a GetSignedVAAResponse {
        <GetSignedVAAResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetSignedVAAResponse {
    pub fn new() -> GetSignedVAAResponse {
        ::std::default::Default::default()
    }

    // bytes vaa_bytes = 1;


    pub fn get_vaa_bytes(&self) -> &[u8] {
        &self.vaa_bytes
    }
    pub fn clear_vaa_bytes(&mut self) {
        self.vaa_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_vaa_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.vaa_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vaa_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.vaa_bytes
    }

    // Take field
    pub fn take_vaa_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.vaa_bytes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetSignedVAAResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.vaa_bytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.vaa_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.vaa_bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.vaa_bytes.is_empty() {
            os.write_bytes(1, &self.vaa_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSignedVAAResponse {
        GetSignedVAAResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "vaa_bytes",
                |m: &GetSignedVAAResponse| { &m.vaa_bytes },
                |m: &mut GetSignedVAAResponse| { &mut m.vaa_bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSignedVAAResponse>(
                "GetSignedVAAResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSignedVAAResponse {
        static instance: ::protobuf::rt::LazyV2<GetSignedVAAResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSignedVAAResponse::new)
    }
}

impl ::protobuf::Clear for GetSignedVAAResponse {
    fn clear(&mut self) {
        self.vaa_bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSignedVAAResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSignedVAAResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSignedBatchVAARequest {
    // message fields
    pub batch_id: ::protobuf::SingularPtrField<BatchID>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSignedBatchVAARequest {
    fn default() -> &'a GetSignedBatchVAARequest {
        <GetSignedBatchVAARequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSignedBatchVAARequest {
    pub fn new() -> GetSignedBatchVAARequest {
        ::std::default::Default::default()
    }

    // .publicrpc.v1.BatchID batch_id = 1;


    pub fn get_batch_id(&self) -> &BatchID {
        self.batch_id.as_ref().unwrap_or_else(|| <BatchID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_batch_id(&mut self) {
        self.batch_id.clear();
    }

    pub fn has_batch_id(&self) -> bool {
        self.batch_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_batch_id(&mut self, v: BatchID) {
        self.batch_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_batch_id(&mut self) -> &mut BatchID {
        if self.batch_id.is_none() {
            self.batch_id.set_default();
        }
        self.batch_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_batch_id(&mut self) -> BatchID {
        self.batch_id.take().unwrap_or_else(|| BatchID::new())
    }
}

impl ::protobuf::Message for GetSignedBatchVAARequest {
    fn is_initialized(&self) -> bool {
        for v in &self.batch_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.batch_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.batch_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.batch_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSignedBatchVAARequest {
        GetSignedBatchVAARequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BatchID>>(
                "batch_id",
                |m: &GetSignedBatchVAARequest| { &m.batch_id },
                |m: &mut GetSignedBatchVAARequest| { &mut m.batch_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSignedBatchVAARequest>(
                "GetSignedBatchVAARequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSignedBatchVAARequest {
        static instance: ::protobuf::rt::LazyV2<GetSignedBatchVAARequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSignedBatchVAARequest::new)
    }
}

impl ::protobuf::Clear for GetSignedBatchVAARequest {
    fn clear(&mut self) {
        self.batch_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSignedBatchVAARequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSignedBatchVAARequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSignedBatchVAAResponse {
    // message fields
    pub signed_batch_vaa: ::protobuf::SingularPtrField<super::gossip::SignedBatchVAAWithQuorum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSignedBatchVAAResponse {
    fn default() -> &'a GetSignedBatchVAAResponse {
        <GetSignedBatchVAAResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetSignedBatchVAAResponse {
    pub fn new() -> GetSignedBatchVAAResponse {
        ::std::default::Default::default()
    }

    // .gossip.v1.SignedBatchVAAWithQuorum signed_batch_vaa = 1;


    pub fn get_signed_batch_vaa(&self) -> &super::gossip::SignedBatchVAAWithQuorum {
        self.signed_batch_vaa.as_ref().unwrap_or_else(|| <super::gossip::SignedBatchVAAWithQuorum as ::protobuf::Message>::default_instance())
    }
    pub fn clear_signed_batch_vaa(&mut self) {
        self.signed_batch_vaa.clear();
    }

    pub fn has_signed_batch_vaa(&self) -> bool {
        self.signed_batch_vaa.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signed_batch_vaa(&mut self, v: super::gossip::SignedBatchVAAWithQuorum) {
        self.signed_batch_vaa = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signed_batch_vaa(&mut self) -> &mut super::gossip::SignedBatchVAAWithQuorum {
        if self.signed_batch_vaa.is_none() {
            self.signed_batch_vaa.set_default();
        }
        self.signed_batch_vaa.as_mut().unwrap()
    }

    // Take field
    pub fn take_signed_batch_vaa(&mut self) -> super::gossip::SignedBatchVAAWithQuorum {
        self.signed_batch_vaa.take().unwrap_or_else(|| super::gossip::SignedBatchVAAWithQuorum::new())
    }
}

impl ::protobuf::Message for GetSignedBatchVAAResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.signed_batch_vaa {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signed_batch_vaa)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signed_batch_vaa.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signed_batch_vaa.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSignedBatchVAAResponse {
        GetSignedBatchVAAResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gossip::SignedBatchVAAWithQuorum>>(
                "signed_batch_vaa",
                |m: &GetSignedBatchVAAResponse| { &m.signed_batch_vaa },
                |m: &mut GetSignedBatchVAAResponse| { &mut m.signed_batch_vaa },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSignedBatchVAAResponse>(
                "GetSignedBatchVAAResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSignedBatchVAAResponse {
        static instance: ::protobuf::rt::LazyV2<GetSignedBatchVAAResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSignedBatchVAAResponse::new)
    }
}

impl ::protobuf::Clear for GetSignedBatchVAAResponse {
    fn clear(&mut self) {
        self.signed_batch_vaa.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSignedBatchVAAResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSignedBatchVAAResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLastHeartbeatsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLastHeartbeatsRequest {
    fn default() -> &'a GetLastHeartbeatsRequest {
        <GetLastHeartbeatsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLastHeartbeatsRequest {
    pub fn new() -> GetLastHeartbeatsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetLastHeartbeatsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLastHeartbeatsRequest {
        GetLastHeartbeatsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLastHeartbeatsRequest>(
                "GetLastHeartbeatsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetLastHeartbeatsRequest {
        static instance: ::protobuf::rt::LazyV2<GetLastHeartbeatsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLastHeartbeatsRequest::new)
    }
}

impl ::protobuf::Clear for GetLastHeartbeatsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLastHeartbeatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLastHeartbeatsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLastHeartbeatsResponse {
    // message fields
    pub entries: ::protobuf::RepeatedField<GetLastHeartbeatsResponse_Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLastHeartbeatsResponse {
    fn default() -> &'a GetLastHeartbeatsResponse {
        <GetLastHeartbeatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetLastHeartbeatsResponse {
    pub fn new() -> GetLastHeartbeatsResponse {
        ::std::default::Default::default()
    }

    // repeated .publicrpc.v1.GetLastHeartbeatsResponse.Entry entries = 1;


    pub fn get_entries(&self) -> &[GetLastHeartbeatsResponse_Entry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<GetLastHeartbeatsResponse_Entry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<GetLastHeartbeatsResponse_Entry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<GetLastHeartbeatsResponse_Entry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetLastHeartbeatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLastHeartbeatsResponse {
        GetLastHeartbeatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetLastHeartbeatsResponse_Entry>>(
                "entries",
                |m: &GetLastHeartbeatsResponse| { &m.entries },
                |m: &mut GetLastHeartbeatsResponse| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLastHeartbeatsResponse>(
                "GetLastHeartbeatsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetLastHeartbeatsResponse {
        static instance: ::protobuf::rt::LazyV2<GetLastHeartbeatsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLastHeartbeatsResponse::new)
    }
}

impl ::protobuf::Clear for GetLastHeartbeatsResponse {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLastHeartbeatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLastHeartbeatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLastHeartbeatsResponse_Entry {
    // message fields
    pub verified_guardian_addr: ::std::string::String,
    pub p2p_node_addr: ::std::string::String,
    pub raw_heartbeat: ::protobuf::SingularPtrField<super::gossip::Heartbeat>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLastHeartbeatsResponse_Entry {
    fn default() -> &'a GetLastHeartbeatsResponse_Entry {
        <GetLastHeartbeatsResponse_Entry as ::protobuf::Message>::default_instance()
    }
}

impl GetLastHeartbeatsResponse_Entry {
    pub fn new() -> GetLastHeartbeatsResponse_Entry {
        ::std::default::Default::default()
    }

    // string verified_guardian_addr = 1;


    pub fn get_verified_guardian_addr(&self) -> &str {
        &self.verified_guardian_addr
    }
    pub fn clear_verified_guardian_addr(&mut self) {
        self.verified_guardian_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_verified_guardian_addr(&mut self, v: ::std::string::String) {
        self.verified_guardian_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verified_guardian_addr(&mut self) -> &mut ::std::string::String {
        &mut self.verified_guardian_addr
    }

    // Take field
    pub fn take_verified_guardian_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.verified_guardian_addr, ::std::string::String::new())
    }

    // string p2p_node_addr = 2;


    pub fn get_p2p_node_addr(&self) -> &str {
        &self.p2p_node_addr
    }
    pub fn clear_p2p_node_addr(&mut self) {
        self.p2p_node_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_p2p_node_addr(&mut self, v: ::std::string::String) {
        self.p2p_node_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2p_node_addr(&mut self) -> &mut ::std::string::String {
        &mut self.p2p_node_addr
    }

    // Take field
    pub fn take_p2p_node_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.p2p_node_addr, ::std::string::String::new())
    }

    // .gossip.v1.Heartbeat raw_heartbeat = 3;


    pub fn get_raw_heartbeat(&self) -> &super::gossip::Heartbeat {
        self.raw_heartbeat.as_ref().unwrap_or_else(|| <super::gossip::Heartbeat as ::protobuf::Message>::default_instance())
    }
    pub fn clear_raw_heartbeat(&mut self) {
        self.raw_heartbeat.clear();
    }

    pub fn has_raw_heartbeat(&self) -> bool {
        self.raw_heartbeat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_heartbeat(&mut self, v: super::gossip::Heartbeat) {
        self.raw_heartbeat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_heartbeat(&mut self) -> &mut super::gossip::Heartbeat {
        if self.raw_heartbeat.is_none() {
            self.raw_heartbeat.set_default();
        }
        self.raw_heartbeat.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_heartbeat(&mut self) -> super::gossip::Heartbeat {
        self.raw_heartbeat.take().unwrap_or_else(|| super::gossip::Heartbeat::new())
    }
}

impl ::protobuf::Message for GetLastHeartbeatsResponse_Entry {
    fn is_initialized(&self) -> bool {
        for v in &self.raw_heartbeat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.verified_guardian_addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.p2p_node_addr)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.raw_heartbeat)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.verified_guardian_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.verified_guardian_addr);
        }
        if !self.p2p_node_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.p2p_node_addr);
        }
        if let Some(ref v) = self.raw_heartbeat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.verified_guardian_addr.is_empty() {
            os.write_string(1, &self.verified_guardian_addr)?;
        }
        if !self.p2p_node_addr.is_empty() {
            os.write_string(2, &self.p2p_node_addr)?;
        }
        if let Some(ref v) = self.raw_heartbeat.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLastHeartbeatsResponse_Entry {
        GetLastHeartbeatsResponse_Entry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "verified_guardian_addr",
                |m: &GetLastHeartbeatsResponse_Entry| { &m.verified_guardian_addr },
                |m: &mut GetLastHeartbeatsResponse_Entry| { &mut m.verified_guardian_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "p2p_node_addr",
                |m: &GetLastHeartbeatsResponse_Entry| { &m.p2p_node_addr },
                |m: &mut GetLastHeartbeatsResponse_Entry| { &mut m.p2p_node_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gossip::Heartbeat>>(
                "raw_heartbeat",
                |m: &GetLastHeartbeatsResponse_Entry| { &m.raw_heartbeat },
                |m: &mut GetLastHeartbeatsResponse_Entry| { &mut m.raw_heartbeat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLastHeartbeatsResponse_Entry>(
                "GetLastHeartbeatsResponse.Entry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetLastHeartbeatsResponse_Entry {
        static instance: ::protobuf::rt::LazyV2<GetLastHeartbeatsResponse_Entry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLastHeartbeatsResponse_Entry::new)
    }
}

impl ::protobuf::Clear for GetLastHeartbeatsResponse_Entry {
    fn clear(&mut self) {
        self.verified_guardian_addr.clear();
        self.p2p_node_addr.clear();
        self.raw_heartbeat.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLastHeartbeatsResponse_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLastHeartbeatsResponse_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCurrentGuardianSetRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCurrentGuardianSetRequest {
    fn default() -> &'a GetCurrentGuardianSetRequest {
        <GetCurrentGuardianSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentGuardianSetRequest {
    pub fn new() -> GetCurrentGuardianSetRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCurrentGuardianSetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCurrentGuardianSetRequest {
        GetCurrentGuardianSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCurrentGuardianSetRequest>(
                "GetCurrentGuardianSetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCurrentGuardianSetRequest {
        static instance: ::protobuf::rt::LazyV2<GetCurrentGuardianSetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCurrentGuardianSetRequest::new)
    }
}

impl ::protobuf::Clear for GetCurrentGuardianSetRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCurrentGuardianSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentGuardianSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCurrentGuardianSetResponse {
    // message fields
    pub guardian_set: ::protobuf::SingularPtrField<GuardianSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCurrentGuardianSetResponse {
    fn default() -> &'a GetCurrentGuardianSetResponse {
        <GetCurrentGuardianSetResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentGuardianSetResponse {
    pub fn new() -> GetCurrentGuardianSetResponse {
        ::std::default::Default::default()
    }

    // .publicrpc.v1.GuardianSet guardian_set = 1;


    pub fn get_guardian_set(&self) -> &GuardianSet {
        self.guardian_set.as_ref().unwrap_or_else(|| <GuardianSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_guardian_set(&mut self) {
        self.guardian_set.clear();
    }

    pub fn has_guardian_set(&self) -> bool {
        self.guardian_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guardian_set(&mut self, v: GuardianSet) {
        self.guardian_set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guardian_set(&mut self) -> &mut GuardianSet {
        if self.guardian_set.is_none() {
            self.guardian_set.set_default();
        }
        self.guardian_set.as_mut().unwrap()
    }

    // Take field
    pub fn take_guardian_set(&mut self) -> GuardianSet {
        self.guardian_set.take().unwrap_or_else(|| GuardianSet::new())
    }
}

impl ::protobuf::Message for GetCurrentGuardianSetResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.guardian_set {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.guardian_set)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.guardian_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.guardian_set.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCurrentGuardianSetResponse {
        GetCurrentGuardianSetResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GuardianSet>>(
                "guardian_set",
                |m: &GetCurrentGuardianSetResponse| { &m.guardian_set },
                |m: &mut GetCurrentGuardianSetResponse| { &mut m.guardian_set },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCurrentGuardianSetResponse>(
                "GetCurrentGuardianSetResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCurrentGuardianSetResponse {
        static instance: ::protobuf::rt::LazyV2<GetCurrentGuardianSetResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCurrentGuardianSetResponse::new)
    }
}

impl ::protobuf::Clear for GetCurrentGuardianSetResponse {
    fn clear(&mut self) {
        self.guardian_set.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCurrentGuardianSetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentGuardianSetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GuardianSet {
    // message fields
    pub index: u32,
    pub addresses: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GuardianSet {
    fn default() -> &'a GuardianSet {
        <GuardianSet as ::protobuf::Message>::default_instance()
    }
}

impl GuardianSet {
    pub fn new() -> GuardianSet {
        ::std::default::Default::default()
    }

    // uint32 index = 1;


    pub fn get_index(&self) -> u32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = v;
    }

    // repeated string addresses = 2;


    pub fn get_addresses(&self) -> &[::std::string::String] {
        &self.addresses
    }
    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GuardianSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.index = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.addresses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.addresses {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.index != 0 {
            os.write_uint32(1, self.index)?;
        }
        for v in &self.addresses {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GuardianSet {
        GuardianSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "index",
                |m: &GuardianSet| { &m.index },
                |m: &mut GuardianSet| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addresses",
                |m: &GuardianSet| { &m.addresses },
                |m: &mut GuardianSet| { &mut m.addresses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GuardianSet>(
                "GuardianSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GuardianSet {
        static instance: ::protobuf::rt::LazyV2<GuardianSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GuardianSet::new)
    }
}

impl ::protobuf::Clear for GuardianSet {
    fn clear(&mut self) {
        self.index = 0;
        self.addresses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GuardianSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GuardianSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GovernorGetAvailableNotionalByChainRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GovernorGetAvailableNotionalByChainRequest {
    fn default() -> &'a GovernorGetAvailableNotionalByChainRequest {
        <GovernorGetAvailableNotionalByChainRequest as ::protobuf::Message>::default_instance()
    }
}

impl GovernorGetAvailableNotionalByChainRequest {
    pub fn new() -> GovernorGetAvailableNotionalByChainRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GovernorGetAvailableNotionalByChainRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GovernorGetAvailableNotionalByChainRequest {
        GovernorGetAvailableNotionalByChainRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GovernorGetAvailableNotionalByChainRequest>(
                "GovernorGetAvailableNotionalByChainRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GovernorGetAvailableNotionalByChainRequest {
        static instance: ::protobuf::rt::LazyV2<GovernorGetAvailableNotionalByChainRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GovernorGetAvailableNotionalByChainRequest::new)
    }
}

impl ::protobuf::Clear for GovernorGetAvailableNotionalByChainRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GovernorGetAvailableNotionalByChainRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorGetAvailableNotionalByChainRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GovernorGetAvailableNotionalByChainResponse {
    // message fields
    pub entries: ::protobuf::RepeatedField<GovernorGetAvailableNotionalByChainResponse_Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GovernorGetAvailableNotionalByChainResponse {
    fn default() -> &'a GovernorGetAvailableNotionalByChainResponse {
        <GovernorGetAvailableNotionalByChainResponse as ::protobuf::Message>::default_instance()
    }
}

impl GovernorGetAvailableNotionalByChainResponse {
    pub fn new() -> GovernorGetAvailableNotionalByChainResponse {
        ::std::default::Default::default()
    }

    // repeated .publicrpc.v1.GovernorGetAvailableNotionalByChainResponse.Entry entries = 1;


    pub fn get_entries(&self) -> &[GovernorGetAvailableNotionalByChainResponse_Entry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<GovernorGetAvailableNotionalByChainResponse_Entry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<GovernorGetAvailableNotionalByChainResponse_Entry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<GovernorGetAvailableNotionalByChainResponse_Entry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GovernorGetAvailableNotionalByChainResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GovernorGetAvailableNotionalByChainResponse {
        GovernorGetAvailableNotionalByChainResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GovernorGetAvailableNotionalByChainResponse_Entry>>(
                "entries",
                |m: &GovernorGetAvailableNotionalByChainResponse| { &m.entries },
                |m: &mut GovernorGetAvailableNotionalByChainResponse| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GovernorGetAvailableNotionalByChainResponse>(
                "GovernorGetAvailableNotionalByChainResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GovernorGetAvailableNotionalByChainResponse {
        static instance: ::protobuf::rt::LazyV2<GovernorGetAvailableNotionalByChainResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GovernorGetAvailableNotionalByChainResponse::new)
    }
}

impl ::protobuf::Clear for GovernorGetAvailableNotionalByChainResponse {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GovernorGetAvailableNotionalByChainResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorGetAvailableNotionalByChainResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GovernorGetAvailableNotionalByChainResponse_Entry {
    // message fields
    pub chain_id: u32,
    pub remaining_available_notional: u64,
    pub notional_limit: u64,
    pub big_transaction_size: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GovernorGetAvailableNotionalByChainResponse_Entry {
    fn default() -> &'a GovernorGetAvailableNotionalByChainResponse_Entry {
        <GovernorGetAvailableNotionalByChainResponse_Entry as ::protobuf::Message>::default_instance()
    }
}

impl GovernorGetAvailableNotionalByChainResponse_Entry {
    pub fn new() -> GovernorGetAvailableNotionalByChainResponse_Entry {
        ::std::default::Default::default()
    }

    // uint32 chain_id = 1;


    pub fn get_chain_id(&self) -> u32 {
        self.chain_id
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: u32) {
        self.chain_id = v;
    }

    // uint64 remaining_available_notional = 2;


    pub fn get_remaining_available_notional(&self) -> u64 {
        self.remaining_available_notional
    }
    pub fn clear_remaining_available_notional(&mut self) {
        self.remaining_available_notional = 0;
    }

    // Param is passed by value, moved
    pub fn set_remaining_available_notional(&mut self, v: u64) {
        self.remaining_available_notional = v;
    }

    // uint64 notional_limit = 3;


    pub fn get_notional_limit(&self) -> u64 {
        self.notional_limit
    }
    pub fn clear_notional_limit(&mut self) {
        self.notional_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_notional_limit(&mut self, v: u64) {
        self.notional_limit = v;
    }

    // uint64 big_transaction_size = 4;


    pub fn get_big_transaction_size(&self) -> u64 {
        self.big_transaction_size
    }
    pub fn clear_big_transaction_size(&mut self) {
        self.big_transaction_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_big_transaction_size(&mut self, v: u64) {
        self.big_transaction_size = v;
    }
}

impl ::protobuf::Message for GovernorGetAvailableNotionalByChainResponse_Entry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.chain_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.remaining_available_notional = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.notional_limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.big_transaction_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chain_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chain_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remaining_available_notional != 0 {
            my_size += ::protobuf::rt::value_size(2, self.remaining_available_notional, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.notional_limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.notional_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.big_transaction_size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.big_transaction_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chain_id != 0 {
            os.write_uint32(1, self.chain_id)?;
        }
        if self.remaining_available_notional != 0 {
            os.write_uint64(2, self.remaining_available_notional)?;
        }
        if self.notional_limit != 0 {
            os.write_uint64(3, self.notional_limit)?;
        }
        if self.big_transaction_size != 0 {
            os.write_uint64(4, self.big_transaction_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GovernorGetAvailableNotionalByChainResponse_Entry {
        GovernorGetAvailableNotionalByChainResponse_Entry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "chain_id",
                |m: &GovernorGetAvailableNotionalByChainResponse_Entry| { &m.chain_id },
                |m: &mut GovernorGetAvailableNotionalByChainResponse_Entry| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "remaining_available_notional",
                |m: &GovernorGetAvailableNotionalByChainResponse_Entry| { &m.remaining_available_notional },
                |m: &mut GovernorGetAvailableNotionalByChainResponse_Entry| { &mut m.remaining_available_notional },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "notional_limit",
                |m: &GovernorGetAvailableNotionalByChainResponse_Entry| { &m.notional_limit },
                |m: &mut GovernorGetAvailableNotionalByChainResponse_Entry| { &mut m.notional_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "big_transaction_size",
                |m: &GovernorGetAvailableNotionalByChainResponse_Entry| { &m.big_transaction_size },
                |m: &mut GovernorGetAvailableNotionalByChainResponse_Entry| { &mut m.big_transaction_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GovernorGetAvailableNotionalByChainResponse_Entry>(
                "GovernorGetAvailableNotionalByChainResponse.Entry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GovernorGetAvailableNotionalByChainResponse_Entry {
        static instance: ::protobuf::rt::LazyV2<GovernorGetAvailableNotionalByChainResponse_Entry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GovernorGetAvailableNotionalByChainResponse_Entry::new)
    }
}

impl ::protobuf::Clear for GovernorGetAvailableNotionalByChainResponse_Entry {
    fn clear(&mut self) {
        self.chain_id = 0;
        self.remaining_available_notional = 0;
        self.notional_limit = 0;
        self.big_transaction_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GovernorGetAvailableNotionalByChainResponse_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorGetAvailableNotionalByChainResponse_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GovernorGetEnqueuedVAAsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GovernorGetEnqueuedVAAsRequest {
    fn default() -> &'a GovernorGetEnqueuedVAAsRequest {
        <GovernorGetEnqueuedVAAsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GovernorGetEnqueuedVAAsRequest {
    pub fn new() -> GovernorGetEnqueuedVAAsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GovernorGetEnqueuedVAAsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GovernorGetEnqueuedVAAsRequest {
        GovernorGetEnqueuedVAAsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GovernorGetEnqueuedVAAsRequest>(
                "GovernorGetEnqueuedVAAsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GovernorGetEnqueuedVAAsRequest {
        static instance: ::protobuf::rt::LazyV2<GovernorGetEnqueuedVAAsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GovernorGetEnqueuedVAAsRequest::new)
    }
}

impl ::protobuf::Clear for GovernorGetEnqueuedVAAsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GovernorGetEnqueuedVAAsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorGetEnqueuedVAAsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GovernorGetEnqueuedVAAsResponse {
    // message fields
    pub entries: ::protobuf::RepeatedField<GovernorGetEnqueuedVAAsResponse_Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GovernorGetEnqueuedVAAsResponse {
    fn default() -> &'a GovernorGetEnqueuedVAAsResponse {
        <GovernorGetEnqueuedVAAsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GovernorGetEnqueuedVAAsResponse {
    pub fn new() -> GovernorGetEnqueuedVAAsResponse {
        ::std::default::Default::default()
    }

    // repeated .publicrpc.v1.GovernorGetEnqueuedVAAsResponse.Entry entries = 1;


    pub fn get_entries(&self) -> &[GovernorGetEnqueuedVAAsResponse_Entry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<GovernorGetEnqueuedVAAsResponse_Entry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<GovernorGetEnqueuedVAAsResponse_Entry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<GovernorGetEnqueuedVAAsResponse_Entry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GovernorGetEnqueuedVAAsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GovernorGetEnqueuedVAAsResponse {
        GovernorGetEnqueuedVAAsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GovernorGetEnqueuedVAAsResponse_Entry>>(
                "entries",
                |m: &GovernorGetEnqueuedVAAsResponse| { &m.entries },
                |m: &mut GovernorGetEnqueuedVAAsResponse| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GovernorGetEnqueuedVAAsResponse>(
                "GovernorGetEnqueuedVAAsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GovernorGetEnqueuedVAAsResponse {
        static instance: ::protobuf::rt::LazyV2<GovernorGetEnqueuedVAAsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GovernorGetEnqueuedVAAsResponse::new)
    }
}

impl ::protobuf::Clear for GovernorGetEnqueuedVAAsResponse {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GovernorGetEnqueuedVAAsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorGetEnqueuedVAAsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GovernorGetEnqueuedVAAsResponse_Entry {
    // message fields
    pub emitter_chain: u32,
    pub emitter_address: ::std::string::String,
    pub sequence: u64,
    pub release_time: u32,
    pub notional_value: u64,
    pub tx_hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GovernorGetEnqueuedVAAsResponse_Entry {
    fn default() -> &'a GovernorGetEnqueuedVAAsResponse_Entry {
        <GovernorGetEnqueuedVAAsResponse_Entry as ::protobuf::Message>::default_instance()
    }
}

impl GovernorGetEnqueuedVAAsResponse_Entry {
    pub fn new() -> GovernorGetEnqueuedVAAsResponse_Entry {
        ::std::default::Default::default()
    }

    // uint32 emitter_chain = 1;


    pub fn get_emitter_chain(&self) -> u32 {
        self.emitter_chain
    }
    pub fn clear_emitter_chain(&mut self) {
        self.emitter_chain = 0;
    }

    // Param is passed by value, moved
    pub fn set_emitter_chain(&mut self, v: u32) {
        self.emitter_chain = v;
    }

    // string emitter_address = 2;


    pub fn get_emitter_address(&self) -> &str {
        &self.emitter_address
    }
    pub fn clear_emitter_address(&mut self) {
        self.emitter_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_emitter_address(&mut self, v: ::std::string::String) {
        self.emitter_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emitter_address(&mut self) -> &mut ::std::string::String {
        &mut self.emitter_address
    }

    // Take field
    pub fn take_emitter_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.emitter_address, ::std::string::String::new())
    }

    // uint64 sequence = 3;


    pub fn get_sequence(&self) -> u64 {
        self.sequence
    }
    pub fn clear_sequence(&mut self) {
        self.sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u64) {
        self.sequence = v;
    }

    // uint32 release_time = 4;


    pub fn get_release_time(&self) -> u32 {
        self.release_time
    }
    pub fn clear_release_time(&mut self) {
        self.release_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_release_time(&mut self, v: u32) {
        self.release_time = v;
    }

    // uint64 notional_value = 5;


    pub fn get_notional_value(&self) -> u64 {
        self.notional_value
    }
    pub fn clear_notional_value(&mut self) {
        self.notional_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_notional_value(&mut self, v: u64) {
        self.notional_value = v;
    }

    // string tx_hash = 6;


    pub fn get_tx_hash(&self) -> &str {
        &self.tx_hash
    }
    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::string::String) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GovernorGetEnqueuedVAAsResponse_Entry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.emitter_chain = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.emitter_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.release_time = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.notional_value = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.emitter_chain != 0 {
            my_size += ::protobuf::rt::value_size(1, self.emitter_chain, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.emitter_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.emitter_address);
        }
        if self.sequence != 0 {
            my_size += ::protobuf::rt::value_size(3, self.sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.release_time != 0 {
            my_size += ::protobuf::rt::value_size(4, self.release_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.notional_value != 0 {
            my_size += ::protobuf::rt::value_size(5, self.notional_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.tx_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.emitter_chain != 0 {
            os.write_uint32(1, self.emitter_chain)?;
        }
        if !self.emitter_address.is_empty() {
            os.write_string(2, &self.emitter_address)?;
        }
        if self.sequence != 0 {
            os.write_uint64(3, self.sequence)?;
        }
        if self.release_time != 0 {
            os.write_uint32(4, self.release_time)?;
        }
        if self.notional_value != 0 {
            os.write_uint64(5, self.notional_value)?;
        }
        if !self.tx_hash.is_empty() {
            os.write_string(6, &self.tx_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GovernorGetEnqueuedVAAsResponse_Entry {
        GovernorGetEnqueuedVAAsResponse_Entry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "emitter_chain",
                |m: &GovernorGetEnqueuedVAAsResponse_Entry| { &m.emitter_chain },
                |m: &mut GovernorGetEnqueuedVAAsResponse_Entry| { &mut m.emitter_chain },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "emitter_address",
                |m: &GovernorGetEnqueuedVAAsResponse_Entry| { &m.emitter_address },
                |m: &mut GovernorGetEnqueuedVAAsResponse_Entry| { &mut m.emitter_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sequence",
                |m: &GovernorGetEnqueuedVAAsResponse_Entry| { &m.sequence },
                |m: &mut GovernorGetEnqueuedVAAsResponse_Entry| { &mut m.sequence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "release_time",
                |m: &GovernorGetEnqueuedVAAsResponse_Entry| { &m.release_time },
                |m: &mut GovernorGetEnqueuedVAAsResponse_Entry| { &mut m.release_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "notional_value",
                |m: &GovernorGetEnqueuedVAAsResponse_Entry| { &m.notional_value },
                |m: &mut GovernorGetEnqueuedVAAsResponse_Entry| { &mut m.notional_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tx_hash",
                |m: &GovernorGetEnqueuedVAAsResponse_Entry| { &m.tx_hash },
                |m: &mut GovernorGetEnqueuedVAAsResponse_Entry| { &mut m.tx_hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GovernorGetEnqueuedVAAsResponse_Entry>(
                "GovernorGetEnqueuedVAAsResponse.Entry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GovernorGetEnqueuedVAAsResponse_Entry {
        static instance: ::protobuf::rt::LazyV2<GovernorGetEnqueuedVAAsResponse_Entry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GovernorGetEnqueuedVAAsResponse_Entry::new)
    }
}

impl ::protobuf::Clear for GovernorGetEnqueuedVAAsResponse_Entry {
    fn clear(&mut self) {
        self.emitter_chain = 0;
        self.emitter_address.clear();
        self.sequence = 0;
        self.release_time = 0;
        self.notional_value = 0;
        self.tx_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GovernorGetEnqueuedVAAsResponse_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorGetEnqueuedVAAsResponse_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GovernorIsVAAEnqueuedRequest {
    // message fields
    pub message_id: ::protobuf::SingularPtrField<MessageID>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GovernorIsVAAEnqueuedRequest {
    fn default() -> &'a GovernorIsVAAEnqueuedRequest {
        <GovernorIsVAAEnqueuedRequest as ::protobuf::Message>::default_instance()
    }
}

impl GovernorIsVAAEnqueuedRequest {
    pub fn new() -> GovernorIsVAAEnqueuedRequest {
        ::std::default::Default::default()
    }

    // .publicrpc.v1.MessageID message_id = 1;


    pub fn get_message_id(&self) -> &MessageID {
        self.message_id.as_ref().unwrap_or_else(|| <MessageID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: MessageID) {
        self.message_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut MessageID {
        if self.message_id.is_none() {
            self.message_id.set_default();
        }
        self.message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_id(&mut self) -> MessageID {
        self.message_id.take().unwrap_or_else(|| MessageID::new())
    }
}

impl ::protobuf::Message for GovernorIsVAAEnqueuedRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.message_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GovernorIsVAAEnqueuedRequest {
        GovernorIsVAAEnqueuedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageID>>(
                "message_id",
                |m: &GovernorIsVAAEnqueuedRequest| { &m.message_id },
                |m: &mut GovernorIsVAAEnqueuedRequest| { &mut m.message_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GovernorIsVAAEnqueuedRequest>(
                "GovernorIsVAAEnqueuedRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GovernorIsVAAEnqueuedRequest {
        static instance: ::protobuf::rt::LazyV2<GovernorIsVAAEnqueuedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GovernorIsVAAEnqueuedRequest::new)
    }
}

impl ::protobuf::Clear for GovernorIsVAAEnqueuedRequest {
    fn clear(&mut self) {
        self.message_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GovernorIsVAAEnqueuedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorIsVAAEnqueuedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GovernorIsVAAEnqueuedResponse {
    // message fields
    pub is_enqueued: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GovernorIsVAAEnqueuedResponse {
    fn default() -> &'a GovernorIsVAAEnqueuedResponse {
        <GovernorIsVAAEnqueuedResponse as ::protobuf::Message>::default_instance()
    }
}

impl GovernorIsVAAEnqueuedResponse {
    pub fn new() -> GovernorIsVAAEnqueuedResponse {
        ::std::default::Default::default()
    }

    // bool is_enqueued = 1;


    pub fn get_is_enqueued(&self) -> bool {
        self.is_enqueued
    }
    pub fn clear_is_enqueued(&mut self) {
        self.is_enqueued = false;
    }

    // Param is passed by value, moved
    pub fn set_is_enqueued(&mut self, v: bool) {
        self.is_enqueued = v;
    }
}

impl ::protobuf::Message for GovernorIsVAAEnqueuedResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_enqueued = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_enqueued != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_enqueued != false {
            os.write_bool(1, self.is_enqueued)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GovernorIsVAAEnqueuedResponse {
        GovernorIsVAAEnqueuedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_enqueued",
                |m: &GovernorIsVAAEnqueuedResponse| { &m.is_enqueued },
                |m: &mut GovernorIsVAAEnqueuedResponse| { &mut m.is_enqueued },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GovernorIsVAAEnqueuedResponse>(
                "GovernorIsVAAEnqueuedResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GovernorIsVAAEnqueuedResponse {
        static instance: ::protobuf::rt::LazyV2<GovernorIsVAAEnqueuedResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GovernorIsVAAEnqueuedResponse::new)
    }
}

impl ::protobuf::Clear for GovernorIsVAAEnqueuedResponse {
    fn clear(&mut self) {
        self.is_enqueued = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GovernorIsVAAEnqueuedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorIsVAAEnqueuedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GovernorGetTokenListRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GovernorGetTokenListRequest {
    fn default() -> &'a GovernorGetTokenListRequest {
        <GovernorGetTokenListRequest as ::protobuf::Message>::default_instance()
    }
}

impl GovernorGetTokenListRequest {
    pub fn new() -> GovernorGetTokenListRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GovernorGetTokenListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GovernorGetTokenListRequest {
        GovernorGetTokenListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GovernorGetTokenListRequest>(
                "GovernorGetTokenListRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GovernorGetTokenListRequest {
        static instance: ::protobuf::rt::LazyV2<GovernorGetTokenListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GovernorGetTokenListRequest::new)
    }
}

impl ::protobuf::Clear for GovernorGetTokenListRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GovernorGetTokenListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorGetTokenListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GovernorGetTokenListResponse {
    // message fields
    pub entries: ::protobuf::RepeatedField<GovernorGetTokenListResponse_Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GovernorGetTokenListResponse {
    fn default() -> &'a GovernorGetTokenListResponse {
        <GovernorGetTokenListResponse as ::protobuf::Message>::default_instance()
    }
}

impl GovernorGetTokenListResponse {
    pub fn new() -> GovernorGetTokenListResponse {
        ::std::default::Default::default()
    }

    // repeated .publicrpc.v1.GovernorGetTokenListResponse.Entry entries = 1;


    pub fn get_entries(&self) -> &[GovernorGetTokenListResponse_Entry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<GovernorGetTokenListResponse_Entry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<GovernorGetTokenListResponse_Entry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<GovernorGetTokenListResponse_Entry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GovernorGetTokenListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GovernorGetTokenListResponse {
        GovernorGetTokenListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GovernorGetTokenListResponse_Entry>>(
                "entries",
                |m: &GovernorGetTokenListResponse| { &m.entries },
                |m: &mut GovernorGetTokenListResponse| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GovernorGetTokenListResponse>(
                "GovernorGetTokenListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GovernorGetTokenListResponse {
        static instance: ::protobuf::rt::LazyV2<GovernorGetTokenListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GovernorGetTokenListResponse::new)
    }
}

impl ::protobuf::Clear for GovernorGetTokenListResponse {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GovernorGetTokenListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorGetTokenListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GovernorGetTokenListResponse_Entry {
    // message fields
    pub origin_chain_id: u32,
    pub origin_address: ::std::string::String,
    pub price: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GovernorGetTokenListResponse_Entry {
    fn default() -> &'a GovernorGetTokenListResponse_Entry {
        <GovernorGetTokenListResponse_Entry as ::protobuf::Message>::default_instance()
    }
}

impl GovernorGetTokenListResponse_Entry {
    pub fn new() -> GovernorGetTokenListResponse_Entry {
        ::std::default::Default::default()
    }

    // uint32 origin_chain_id = 1;


    pub fn get_origin_chain_id(&self) -> u32 {
        self.origin_chain_id
    }
    pub fn clear_origin_chain_id(&mut self) {
        self.origin_chain_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_origin_chain_id(&mut self, v: u32) {
        self.origin_chain_id = v;
    }

    // string origin_address = 2;


    pub fn get_origin_address(&self) -> &str {
        &self.origin_address
    }
    pub fn clear_origin_address(&mut self) {
        self.origin_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_origin_address(&mut self, v: ::std::string::String) {
        self.origin_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin_address(&mut self) -> &mut ::std::string::String {
        &mut self.origin_address
    }

    // Take field
    pub fn take_origin_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.origin_address, ::std::string::String::new())
    }

    // float price = 3;


    pub fn get_price(&self) -> f32 {
        self.price
    }
    pub fn clear_price(&mut self) {
        self.price = 0.;
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: f32) {
        self.price = v;
    }
}

impl ::protobuf::Message for GovernorGetTokenListResponse_Entry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.origin_chain_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.origin_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.price = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.origin_chain_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.origin_chain_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.origin_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.origin_address);
        }
        if self.price != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.origin_chain_id != 0 {
            os.write_uint32(1, self.origin_chain_id)?;
        }
        if !self.origin_address.is_empty() {
            os.write_string(2, &self.origin_address)?;
        }
        if self.price != 0. {
            os.write_float(3, self.price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GovernorGetTokenListResponse_Entry {
        GovernorGetTokenListResponse_Entry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "origin_chain_id",
                |m: &GovernorGetTokenListResponse_Entry| { &m.origin_chain_id },
                |m: &mut GovernorGetTokenListResponse_Entry| { &mut m.origin_chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "origin_address",
                |m: &GovernorGetTokenListResponse_Entry| { &m.origin_address },
                |m: &mut GovernorGetTokenListResponse_Entry| { &mut m.origin_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "price",
                |m: &GovernorGetTokenListResponse_Entry| { &m.price },
                |m: &mut GovernorGetTokenListResponse_Entry| { &mut m.price },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GovernorGetTokenListResponse_Entry>(
                "GovernorGetTokenListResponse.Entry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GovernorGetTokenListResponse_Entry {
        static instance: ::protobuf::rt::LazyV2<GovernorGetTokenListResponse_Entry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GovernorGetTokenListResponse_Entry::new)
    }
}

impl ::protobuf::Clear for GovernorGetTokenListResponse_Entry {
    fn clear(&mut self) {
        self.origin_chain_id = 0;
        self.origin_address.clear();
        self.price = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GovernorGetTokenListResponse_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorGetTokenListResponse_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ChainID {
    CHAIN_ID_UNSPECIFIED = 0,
    CHAIN_ID_SOLANA = 1,
    CHAIN_ID_ETHEREUM = 2,
    CHAIN_ID_TERRA = 3,
    CHAIN_ID_BSC = 4,
    CHAIN_ID_POLYGON = 5,
    CHAIN_ID_AVALANCHE = 6,
    CHAIN_ID_OASIS = 7,
    CHAIN_ID_ALGORAND = 8,
    CHAIN_ID_AURORA = 9,
    CHAIN_ID_FANTOM = 10,
    CHAIN_ID_KARURA = 11,
    CHAIN_ID_ACALA = 12,
    CHAIN_ID_KLAYTN = 13,
    CHAIN_ID_CELO = 14,
    CHAIN_ID_NEAR = 15,
    CHAIN_ID_MOONBEAM = 16,
    CHAIN_ID_NEON = 17,
    CHAIN_ID_TERRA2 = 18,
    CHAIN_ID_INJECTIVE = 19,
    CHAIN_ID_OSMOSIS = 20,
    CHAIN_ID_SUI = 21,
    CHAIN_ID_APTOS = 22,
    CHAIN_ID_ARBITRUM = 23,
    CHAIN_ID_OPTIMISM = 24,
    CHAIN_ID_GNOSIS = 25,
    CHAIN_ID_PYTHNET = 26,
    CHAIN_ID_XPLA = 28,
    CHAIN_ID_BTC = 29,
    CHAIN_ID_BASE = 30,
    CHAIN_ID_SEI = 32,
    CHAIN_ID_SEPOLIA = 10002,
}

impl ::protobuf::ProtobufEnum for ChainID {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChainID> {
        match value {
            0 => ::std::option::Option::Some(ChainID::CHAIN_ID_UNSPECIFIED),
            1 => ::std::option::Option::Some(ChainID::CHAIN_ID_SOLANA),
            2 => ::std::option::Option::Some(ChainID::CHAIN_ID_ETHEREUM),
            3 => ::std::option::Option::Some(ChainID::CHAIN_ID_TERRA),
            4 => ::std::option::Option::Some(ChainID::CHAIN_ID_BSC),
            5 => ::std::option::Option::Some(ChainID::CHAIN_ID_POLYGON),
            6 => ::std::option::Option::Some(ChainID::CHAIN_ID_AVALANCHE),
            7 => ::std::option::Option::Some(ChainID::CHAIN_ID_OASIS),
            8 => ::std::option::Option::Some(ChainID::CHAIN_ID_ALGORAND),
            9 => ::std::option::Option::Some(ChainID::CHAIN_ID_AURORA),
            10 => ::std::option::Option::Some(ChainID::CHAIN_ID_FANTOM),
            11 => ::std::option::Option::Some(ChainID::CHAIN_ID_KARURA),
            12 => ::std::option::Option::Some(ChainID::CHAIN_ID_ACALA),
            13 => ::std::option::Option::Some(ChainID::CHAIN_ID_KLAYTN),
            14 => ::std::option::Option::Some(ChainID::CHAIN_ID_CELO),
            15 => ::std::option::Option::Some(ChainID::CHAIN_ID_NEAR),
            16 => ::std::option::Option::Some(ChainID::CHAIN_ID_MOONBEAM),
            17 => ::std::option::Option::Some(ChainID::CHAIN_ID_NEON),
            18 => ::std::option::Option::Some(ChainID::CHAIN_ID_TERRA2),
            19 => ::std::option::Option::Some(ChainID::CHAIN_ID_INJECTIVE),
            20 => ::std::option::Option::Some(ChainID::CHAIN_ID_OSMOSIS),
            21 => ::std::option::Option::Some(ChainID::CHAIN_ID_SUI),
            22 => ::std::option::Option::Some(ChainID::CHAIN_ID_APTOS),
            23 => ::std::option::Option::Some(ChainID::CHAIN_ID_ARBITRUM),
            24 => ::std::option::Option::Some(ChainID::CHAIN_ID_OPTIMISM),
            25 => ::std::option::Option::Some(ChainID::CHAIN_ID_GNOSIS),
            26 => ::std::option::Option::Some(ChainID::CHAIN_ID_PYTHNET),
            28 => ::std::option::Option::Some(ChainID::CHAIN_ID_XPLA),
            29 => ::std::option::Option::Some(ChainID::CHAIN_ID_BTC),
            30 => ::std::option::Option::Some(ChainID::CHAIN_ID_BASE),
            32 => ::std::option::Option::Some(ChainID::CHAIN_ID_SEI),
            10002 => ::std::option::Option::Some(ChainID::CHAIN_ID_SEPOLIA),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChainID] = &[
            ChainID::CHAIN_ID_UNSPECIFIED,
            ChainID::CHAIN_ID_SOLANA,
            ChainID::CHAIN_ID_ETHEREUM,
            ChainID::CHAIN_ID_TERRA,
            ChainID::CHAIN_ID_BSC,
            ChainID::CHAIN_ID_POLYGON,
            ChainID::CHAIN_ID_AVALANCHE,
            ChainID::CHAIN_ID_OASIS,
            ChainID::CHAIN_ID_ALGORAND,
            ChainID::CHAIN_ID_AURORA,
            ChainID::CHAIN_ID_FANTOM,
            ChainID::CHAIN_ID_KARURA,
            ChainID::CHAIN_ID_ACALA,
            ChainID::CHAIN_ID_KLAYTN,
            ChainID::CHAIN_ID_CELO,
            ChainID::CHAIN_ID_NEAR,
            ChainID::CHAIN_ID_MOONBEAM,
            ChainID::CHAIN_ID_NEON,
            ChainID::CHAIN_ID_TERRA2,
            ChainID::CHAIN_ID_INJECTIVE,
            ChainID::CHAIN_ID_OSMOSIS,
            ChainID::CHAIN_ID_SUI,
            ChainID::CHAIN_ID_APTOS,
            ChainID::CHAIN_ID_ARBITRUM,
            ChainID::CHAIN_ID_OPTIMISM,
            ChainID::CHAIN_ID_GNOSIS,
            ChainID::CHAIN_ID_PYTHNET,
            ChainID::CHAIN_ID_XPLA,
            ChainID::CHAIN_ID_BTC,
            ChainID::CHAIN_ID_BASE,
            ChainID::CHAIN_ID_SEI,
            ChainID::CHAIN_ID_SEPOLIA,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ChainID>("ChainID", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ChainID {
}

impl ::std::default::Default for ChainID {
    fn default() -> Self {
        ChainID::CHAIN_ID_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainID {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cpublicrpc/v1/publicrpc.proto\x12\x0cpublicrpc.v1\x1a\x16gossip/v1/\
    gossip.proto\x1a\x1cgoogle/api/annotations.proto\"\x8c\x01\n\tMessageID\
    \x12:\n\remitter_chain\x18\x01\x20\x01(\x0e2\x15.publicrpc.v1.ChainIDR\
    \x0cemitterChain\x12'\n\x0femitter_address\x18\x02\x20\x01(\tR\x0eemitte\
    rAddress\x12\x1a\n\x08sequence\x18\x03\x20\x01(\x04R\x08sequence\"p\n\
    \x07BatchID\x12:\n\remitter_chain\x18\x01\x20\x01(\x0e2\x15.publicrpc.v1\
    .ChainIDR\x0cemitterChain\x12\x13\n\x05tx_id\x18\x02\x20\x01(\x0cR\x04tx\
    Id\x12\x14\n\x05nonce\x18\x03\x20\x01(\rR\x05nonce\"M\n\x13GetSignedVAAR\
    equest\x126\n\nmessage_id\x18\x01\x20\x01(\x0b2\x17.publicrpc.v1.Message\
    IDR\tmessageId\"3\n\x14GetSignedVAAResponse\x12\x1b\n\tvaa_bytes\x18\x01\
    \x20\x01(\x0cR\x08vaaBytes\"L\n\x18GetSignedBatchVAARequest\x120\n\x08ba\
    tch_id\x18\x01\x20\x01(\x0b2\x15.publicrpc.v1.BatchIDR\x07batchId\"j\n\
    \x19GetSignedBatchVAAResponse\x12M\n\x10signed_batch_vaa\x18\x01\x20\x01\
    (\x0b2#.gossip.v1.SignedBatchVAAWithQuorumR\x0esignedBatchVaa\"\x1a\n\
    \x18GetLastHeartbeatsRequest\"\x83\x02\n\x19GetLastHeartbeatsResponse\
    \x12G\n\x07entries\x18\x01\x20\x03(\x0b2-.publicrpc.v1.GetLastHeartbeats\
    Response.EntryR\x07entries\x1a\x9c\x01\n\x05Entry\x124\n\x16verified_gua\
    rdian_addr\x18\x01\x20\x01(\tR\x14verifiedGuardianAddr\x12\"\n\rp2p_node\
    _addr\x18\x02\x20\x01(\tR\x0bp2pNodeAddr\x129\n\rraw_heartbeat\x18\x03\
    \x20\x01(\x0b2\x14.gossip.v1.HeartbeatR\x0crawHeartbeat\"\x1e\n\x1cGetCu\
    rrentGuardianSetRequest\"]\n\x1dGetCurrentGuardianSetResponse\x12<\n\x0c\
    guardian_set\x18\x01\x20\x01(\x0b2\x19.publicrpc.v1.GuardianSetR\x0bguar\
    dianSet\"A\n\x0bGuardianSet\x12\x14\n\x05index\x18\x01\x20\x01(\rR\x05in\
    dex\x12\x1c\n\taddresses\x18\x02\x20\x03(\tR\taddresses\",\n*GovernorGet\
    AvailableNotionalByChainRequest\"\xc8\x02\n+GovernorGetAvailableNotional\
    ByChainResponse\x12Y\n\x07entries\x18\x01\x20\x03(\x0b2?.publicrpc.v1.Go\
    vernorGetAvailableNotionalByChainResponse.EntryR\x07entries\x1a\xbd\x01\
    \n\x05Entry\x12\x19\n\x08chain_id\x18\x01\x20\x01(\rR\x07chainId\x12@\n\
    \x1cremaining_available_notional\x18\x02\x20\x01(\x04R\x1aremainingAvail\
    ableNotional\x12%\n\x0enotional_limit\x18\x03\x20\x01(\x04R\rnotionalLim\
    it\x120\n\x14big_transaction_size\x18\x04\x20\x01(\x04R\x12bigTransactio\
    nSize\"\x20\n\x1eGovernorGetEnqueuedVAAsRequest\"\xc7\x02\n\x1fGovernorG\
    etEnqueuedVAAsResponse\x12M\n\x07entries\x18\x01\x20\x03(\x0b23.publicrp\
    c.v1.GovernorGetEnqueuedVAAsResponse.EntryR\x07entries\x1a\xd4\x01\n\x05\
    Entry\x12#\n\remitter_chain\x18\x01\x20\x01(\rR\x0cemitterChain\x12'\n\
    \x0femitter_address\x18\x02\x20\x01(\tR\x0eemitterAddress\x12\x1a\n\x08s\
    equence\x18\x03\x20\x01(\x04R\x08sequence\x12!\n\x0crelease_time\x18\x04\
    \x20\x01(\rR\x0breleaseTime\x12%\n\x0enotional_value\x18\x05\x20\x01(\
    \x04R\rnotionalValue\x12\x17\n\x07tx_hash\x18\x06\x20\x01(\tR\x06txHash\
    \"V\n\x1cGovernorIsVAAEnqueuedRequest\x126\n\nmessage_id\x18\x01\x20\x01\
    (\x0b2\x17.publicrpc.v1.MessageIDR\tmessageId\"@\n\x1dGovernorIsVAAEnque\
    uedResponse\x12\x1f\n\x0bis_enqueued\x18\x01\x20\x01(\x08R\nisEnqueued\"\
    \x1d\n\x1bGovernorGetTokenListRequest\"\xd8\x01\n\x1cGovernorGetTokenLis\
    tResponse\x12J\n\x07entries\x18\x01\x20\x03(\x0b20.publicrpc.v1.Governor\
    GetTokenListResponse.EntryR\x07entries\x1al\n\x05Entry\x12&\n\x0forigin_\
    chain_id\x18\x01\x20\x01(\rR\roriginChainId\x12%\n\x0eorigin_address\x18\
    \x02\x20\x01(\tR\roriginAddress\x12\x14\n\x05price\x18\x03\x20\x01(\x02R\
    \x05price*\xa9\x05\n\x07ChainID\x12\x18\n\x14CHAIN_ID_UNSPECIFIED\x10\0\
    \x12\x13\n\x0fCHAIN_ID_SOLANA\x10\x01\x12\x15\n\x11CHAIN_ID_ETHEREUM\x10\
    \x02\x12\x12\n\x0eCHAIN_ID_TERRA\x10\x03\x12\x10\n\x0cCHAIN_ID_BSC\x10\
    \x04\x12\x14\n\x10CHAIN_ID_POLYGON\x10\x05\x12\x16\n\x12CHAIN_ID_AVALANC\
    HE\x10\x06\x12\x12\n\x0eCHAIN_ID_OASIS\x10\x07\x12\x15\n\x11CHAIN_ID_ALG\
    ORAND\x10\x08\x12\x13\n\x0fCHAIN_ID_AURORA\x10\t\x12\x13\n\x0fCHAIN_ID_F\
    ANTOM\x10\n\x12\x13\n\x0fCHAIN_ID_KARURA\x10\x0b\x12\x12\n\x0eCHAIN_ID_A\
    CALA\x10\x0c\x12\x13\n\x0fCHAIN_ID_KLAYTN\x10\r\x12\x11\n\rCHAIN_ID_CELO\
    \x10\x0e\x12\x11\n\rCHAIN_ID_NEAR\x10\x0f\x12\x15\n\x11CHAIN_ID_MOONBEAM\
    \x10\x10\x12\x11\n\rCHAIN_ID_NEON\x10\x11\x12\x13\n\x0fCHAIN_ID_TERRA2\
    \x10\x12\x12\x16\n\x12CHAIN_ID_INJECTIVE\x10\x13\x12\x14\n\x10CHAIN_ID_O\
    SMOSIS\x10\x14\x12\x10\n\x0cCHAIN_ID_SUI\x10\x15\x12\x12\n\x0eCHAIN_ID_A\
    PTOS\x10\x16\x12\x15\n\x11CHAIN_ID_ARBITRUM\x10\x17\x12\x15\n\x11CHAIN_I\
    D_OPTIMISM\x10\x18\x12\x13\n\x0fCHAIN_ID_GNOSIS\x10\x19\x12\x14\n\x10CHA\
    IN_ID_PYTHNET\x10\x1a\x12\x11\n\rCHAIN_ID_XPLA\x10\x1c\x12\x10\n\x0cCHAI\
    N_ID_BTC\x10\x1d\x12\x11\n\rCHAIN_ID_BASE\x10\x1e\x12\x10\n\x0cCHAIN_ID_\
    SEI\x10\x20\x12\x15\n\x10CHAIN_ID_SEPOLIA\x10\x92N2\x86\x0b\n\x10PublicR\
    PCService\x12|\n\x11GetLastHeartbeats\x12&.publicrpc.v1.GetLastHeartbeat\
    sRequest\x1a'.publicrpc.v1.GetLastHeartbeatsResponse\"\x16\x82\xd3\xe4\
    \x93\x02\x10\x12\x0e/v1/heartbeats\x12\xbb\x01\n\x0cGetSignedVAA\x12!.pu\
    blicrpc.v1.GetSignedVAARequest\x1a\".publicrpc.v1.GetSignedVAAResponse\"\
    d\x82\xd3\xe4\x93\x02^\x12\\/v1/signed_vaa/{message_id.emitter_chain}/{m\
    essage_id.emitter_address}/{message_id.sequence}\x12\xbd\x01\n\x11GetSig\
    nedBatchVAA\x12&.publicrpc.v1.GetSignedBatchVAARequest\x1a'.publicrpc.v1\
    .GetSignedBatchVAAResponse\"W\x82\xd3\xe4\x93\x02Q\x12O/v1/signed_batch_\
    vaa/{batch_id.emitter_chain}/{batch_id.tx_id}/{batch_id.nonce}\x12\x91\
    \x01\n\x15GetCurrentGuardianSet\x12*.publicrpc.v1.GetCurrentGuardianSetR\
    equest\x1a+.publicrpc.v1.GetCurrentGuardianSetResponse\"\x1f\x82\xd3\xe4\
    \x93\x02\x19\x12\x17/v1/guardianset/current\x12\xcc\x01\n#GovernorGetAva\
    ilableNotionalByChain\x128.publicrpc.v1.GovernorGetAvailableNotionalByCh\
    ainRequest\x1a9.publicrpc.v1.GovernorGetAvailableNotionalByChainResponse\
    \"0\x82\xd3\xe4\x93\x02*\x12(/v1/governor/available_notional_by_chain\
    \x12\x9a\x01\n\x17GovernorGetEnqueuedVAAs\x12,.publicrpc.v1.GovernorGetE\
    nqueuedVAAsRequest\x1a-.publicrpc.v1.GovernorGetEnqueuedVAAsResponse\"\"\
    \x82\xd3\xe4\x93\x02\x1c\x12\x1a/v1/governor/enqueued_vaas\x12\xe4\x01\n\
    \x15GovernorIsVAAEnqueued\x12*.publicrpc.v1.GovernorIsVAAEnqueuedRequest\
    \x1a+.publicrpc.v1.GovernorIsVAAEnqueuedResponse\"r\x82\xd3\xe4\x93\x02l\
    \x12j/v1/governor/is_vaa_enqueued/{message_id.emitter_chain}/{message_id\
    .emitter_address}/{message_id.sequence}\x12\x8e\x01\n\x14GovernorGetToke\
    nList\x12).publicrpc.v1.GovernorGetTokenListRequest\x1a*.publicrpc.v1.Go\
    vernorGetTokenListResponse\"\x1f\x82\xd3\xe4\x93\x02\x19\x12\x17/v1/gove\
    rnor/token_listBGZEgithub.com/certusone/wormhole/node/pkg/proto/publicrp\
    c/v1;publicrpcv1b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
