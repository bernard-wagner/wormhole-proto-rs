// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.21.12
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `publicrpc/v1/publicrpc.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.MessageID)
pub struct MessageID {
    // message fields
    // @@protoc_insertion_point(field:publicrpc.v1.MessageID.emitter_chain)
    pub emitter_chain: ::protobuf::EnumOrUnknown<ChainID>,
    // @@protoc_insertion_point(field:publicrpc.v1.MessageID.emitter_address)
    pub emitter_address: ::std::string::String,
    // @@protoc_insertion_point(field:publicrpc.v1.MessageID.sequence)
    pub sequence: u64,
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.MessageID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageID {
    fn default() -> &'a MessageID {
        <MessageID as ::protobuf::Message>::default_instance()
    }
}

impl MessageID {
    pub fn new() -> MessageID {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "emitter_chain",
            |m: &MessageID| { &m.emitter_chain },
            |m: &mut MessageID| { &mut m.emitter_chain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "emitter_address",
            |m: &MessageID| { &m.emitter_address },
            |m: &mut MessageID| { &mut m.emitter_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence",
            |m: &MessageID| { &m.sequence },
            |m: &mut MessageID| { &mut m.sequence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageID>(
            "MessageID",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageID {
    const NAME: &'static str = "MessageID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.emitter_chain = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.emitter_address = is.read_string()?;
                },
                24 => {
                    self.sequence = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.emitter_chain != ::protobuf::EnumOrUnknown::new(ChainID::CHAIN_ID_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.emitter_chain.value());
        }
        if !self.emitter_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.emitter_address);
        }
        if self.sequence != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.sequence);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.emitter_chain != ::protobuf::EnumOrUnknown::new(ChainID::CHAIN_ID_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.emitter_chain))?;
        }
        if !self.emitter_address.is_empty() {
            os.write_string(2, &self.emitter_address)?;
        }
        if self.sequence != 0 {
            os.write_uint64(3, self.sequence)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageID {
        MessageID::new()
    }

    fn clear(&mut self) {
        self.emitter_chain = ::protobuf::EnumOrUnknown::new(ChainID::CHAIN_ID_UNSPECIFIED);
        self.emitter_address.clear();
        self.sequence = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageID {
        static instance: MessageID = MessageID {
            emitter_chain: ::protobuf::EnumOrUnknown::from_i32(0),
            emitter_address: ::std::string::String::new(),
            sequence: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageID {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageID {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.BatchID)
pub struct BatchID {
    // message fields
    // @@protoc_insertion_point(field:publicrpc.v1.BatchID.emitter_chain)
    pub emitter_chain: ::protobuf::EnumOrUnknown<ChainID>,
    // @@protoc_insertion_point(field:publicrpc.v1.BatchID.tx_id)
    pub tx_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:publicrpc.v1.BatchID.nonce)
    pub nonce: u32,
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.BatchID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BatchID {
    fn default() -> &'a BatchID {
        <BatchID as ::protobuf::Message>::default_instance()
    }
}

impl BatchID {
    pub fn new() -> BatchID {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "emitter_chain",
            |m: &BatchID| { &m.emitter_chain },
            |m: &mut BatchID| { &mut m.emitter_chain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tx_id",
            |m: &BatchID| { &m.tx_id },
            |m: &mut BatchID| { &mut m.tx_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nonce",
            |m: &BatchID| { &m.nonce },
            |m: &mut BatchID| { &mut m.nonce },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BatchID>(
            "BatchID",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BatchID {
    const NAME: &'static str = "BatchID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.emitter_chain = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.tx_id = is.read_bytes()?;
                },
                24 => {
                    self.nonce = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.emitter_chain != ::protobuf::EnumOrUnknown::new(ChainID::CHAIN_ID_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.emitter_chain.value());
        }
        if !self.tx_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.tx_id);
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.nonce);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.emitter_chain != ::protobuf::EnumOrUnknown::new(ChainID::CHAIN_ID_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.emitter_chain))?;
        }
        if !self.tx_id.is_empty() {
            os.write_bytes(2, &self.tx_id)?;
        }
        if self.nonce != 0 {
            os.write_uint32(3, self.nonce)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BatchID {
        BatchID::new()
    }

    fn clear(&mut self) {
        self.emitter_chain = ::protobuf::EnumOrUnknown::new(ChainID::CHAIN_ID_UNSPECIFIED);
        self.tx_id.clear();
        self.nonce = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BatchID {
        static instance: BatchID = BatchID {
            emitter_chain: ::protobuf::EnumOrUnknown::from_i32(0),
            tx_id: ::std::vec::Vec::new(),
            nonce: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BatchID {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BatchID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BatchID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchID {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GetSignedVAARequest)
pub struct GetSignedVAARequest {
    // message fields
    // @@protoc_insertion_point(field:publicrpc.v1.GetSignedVAARequest.message_id)
    pub message_id: ::protobuf::MessageField<MessageID>,
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GetSignedVAARequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSignedVAARequest {
    fn default() -> &'a GetSignedVAARequest {
        <GetSignedVAARequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSignedVAARequest {
    pub fn new() -> GetSignedVAARequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageID>(
            "message_id",
            |m: &GetSignedVAARequest| { &m.message_id },
            |m: &mut GetSignedVAARequest| { &mut m.message_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSignedVAARequest>(
            "GetSignedVAARequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSignedVAARequest {
    const NAME: &'static str = "GetSignedVAARequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSignedVAARequest {
        GetSignedVAARequest::new()
    }

    fn clear(&mut self) {
        self.message_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSignedVAARequest {
        static instance: GetSignedVAARequest = GetSignedVAARequest {
            message_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSignedVAARequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSignedVAARequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSignedVAARequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSignedVAARequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GetSignedVAAResponse)
pub struct GetSignedVAAResponse {
    // message fields
    // @@protoc_insertion_point(field:publicrpc.v1.GetSignedVAAResponse.vaa_bytes)
    pub vaa_bytes: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GetSignedVAAResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSignedVAAResponse {
    fn default() -> &'a GetSignedVAAResponse {
        <GetSignedVAAResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetSignedVAAResponse {
    pub fn new() -> GetSignedVAAResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vaa_bytes",
            |m: &GetSignedVAAResponse| { &m.vaa_bytes },
            |m: &mut GetSignedVAAResponse| { &mut m.vaa_bytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSignedVAAResponse>(
            "GetSignedVAAResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSignedVAAResponse {
    const NAME: &'static str = "GetSignedVAAResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.vaa_bytes = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.vaa_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.vaa_bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.vaa_bytes.is_empty() {
            os.write_bytes(1, &self.vaa_bytes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSignedVAAResponse {
        GetSignedVAAResponse::new()
    }

    fn clear(&mut self) {
        self.vaa_bytes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSignedVAAResponse {
        static instance: GetSignedVAAResponse = GetSignedVAAResponse {
            vaa_bytes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSignedVAAResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSignedVAAResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSignedVAAResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSignedVAAResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GetSignedBatchVAARequest)
pub struct GetSignedBatchVAARequest {
    // message fields
    // @@protoc_insertion_point(field:publicrpc.v1.GetSignedBatchVAARequest.batch_id)
    pub batch_id: ::protobuf::MessageField<BatchID>,
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GetSignedBatchVAARequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSignedBatchVAARequest {
    fn default() -> &'a GetSignedBatchVAARequest {
        <GetSignedBatchVAARequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSignedBatchVAARequest {
    pub fn new() -> GetSignedBatchVAARequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BatchID>(
            "batch_id",
            |m: &GetSignedBatchVAARequest| { &m.batch_id },
            |m: &mut GetSignedBatchVAARequest| { &mut m.batch_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSignedBatchVAARequest>(
            "GetSignedBatchVAARequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSignedBatchVAARequest {
    const NAME: &'static str = "GetSignedBatchVAARequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.batch_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.batch_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.batch_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSignedBatchVAARequest {
        GetSignedBatchVAARequest::new()
    }

    fn clear(&mut self) {
        self.batch_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSignedBatchVAARequest {
        static instance: GetSignedBatchVAARequest = GetSignedBatchVAARequest {
            batch_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSignedBatchVAARequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSignedBatchVAARequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSignedBatchVAARequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSignedBatchVAARequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GetSignedBatchVAAResponse)
pub struct GetSignedBatchVAAResponse {
    // message fields
    // @@protoc_insertion_point(field:publicrpc.v1.GetSignedBatchVAAResponse.signed_batch_vaa)
    pub signed_batch_vaa: ::protobuf::MessageField<super::gossip::SignedBatchVAAWithQuorum>,
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GetSignedBatchVAAResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSignedBatchVAAResponse {
    fn default() -> &'a GetSignedBatchVAAResponse {
        <GetSignedBatchVAAResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetSignedBatchVAAResponse {
    pub fn new() -> GetSignedBatchVAAResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::gossip::SignedBatchVAAWithQuorum>(
            "signed_batch_vaa",
            |m: &GetSignedBatchVAAResponse| { &m.signed_batch_vaa },
            |m: &mut GetSignedBatchVAAResponse| { &mut m.signed_batch_vaa },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSignedBatchVAAResponse>(
            "GetSignedBatchVAAResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSignedBatchVAAResponse {
    const NAME: &'static str = "GetSignedBatchVAAResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.signed_batch_vaa)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.signed_batch_vaa.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.signed_batch_vaa.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSignedBatchVAAResponse {
        GetSignedBatchVAAResponse::new()
    }

    fn clear(&mut self) {
        self.signed_batch_vaa.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSignedBatchVAAResponse {
        static instance: GetSignedBatchVAAResponse = GetSignedBatchVAAResponse {
            signed_batch_vaa: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSignedBatchVAAResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSignedBatchVAAResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSignedBatchVAAResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSignedBatchVAAResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GetLastHeartbeatsRequest)
pub struct GetLastHeartbeatsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GetLastHeartbeatsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetLastHeartbeatsRequest {
    fn default() -> &'a GetLastHeartbeatsRequest {
        <GetLastHeartbeatsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLastHeartbeatsRequest {
    pub fn new() -> GetLastHeartbeatsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetLastHeartbeatsRequest>(
            "GetLastHeartbeatsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetLastHeartbeatsRequest {
    const NAME: &'static str = "GetLastHeartbeatsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetLastHeartbeatsRequest {
        GetLastHeartbeatsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetLastHeartbeatsRequest {
        static instance: GetLastHeartbeatsRequest = GetLastHeartbeatsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetLastHeartbeatsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetLastHeartbeatsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetLastHeartbeatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLastHeartbeatsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GetLastHeartbeatsResponse)
pub struct GetLastHeartbeatsResponse {
    // message fields
    // @@protoc_insertion_point(field:publicrpc.v1.GetLastHeartbeatsResponse.entries)
    pub entries: ::std::vec::Vec<get_last_heartbeats_response::Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GetLastHeartbeatsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetLastHeartbeatsResponse {
    fn default() -> &'a GetLastHeartbeatsResponse {
        <GetLastHeartbeatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetLastHeartbeatsResponse {
    pub fn new() -> GetLastHeartbeatsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &GetLastHeartbeatsResponse| { &m.entries },
            |m: &mut GetLastHeartbeatsResponse| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetLastHeartbeatsResponse>(
            "GetLastHeartbeatsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetLastHeartbeatsResponse {
    const NAME: &'static str = "GetLastHeartbeatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetLastHeartbeatsResponse {
        GetLastHeartbeatsResponse::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetLastHeartbeatsResponse {
        static instance: GetLastHeartbeatsResponse = GetLastHeartbeatsResponse {
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetLastHeartbeatsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetLastHeartbeatsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetLastHeartbeatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLastHeartbeatsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GetLastHeartbeatsResponse`
pub mod get_last_heartbeats_response {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:publicrpc.v1.GetLastHeartbeatsResponse.Entry)
    pub struct Entry {
        // message fields
        // @@protoc_insertion_point(field:publicrpc.v1.GetLastHeartbeatsResponse.Entry.verified_guardian_addr)
        pub verified_guardian_addr: ::std::string::String,
        // @@protoc_insertion_point(field:publicrpc.v1.GetLastHeartbeatsResponse.Entry.p2p_node_addr)
        pub p2p_node_addr: ::std::string::String,
        // @@protoc_insertion_point(field:publicrpc.v1.GetLastHeartbeatsResponse.Entry.raw_heartbeat)
        pub raw_heartbeat: ::protobuf::MessageField<super::super::gossip::Heartbeat>,
        // special fields
        // @@protoc_insertion_point(special_field:publicrpc.v1.GetLastHeartbeatsResponse.Entry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Entry {
        fn default() -> &'a Entry {
            <Entry as ::protobuf::Message>::default_instance()
        }
    }

    impl Entry {
        pub fn new() -> Entry {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "verified_guardian_addr",
                |m: &Entry| { &m.verified_guardian_addr },
                |m: &mut Entry| { &mut m.verified_guardian_addr },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "p2p_node_addr",
                |m: &Entry| { &m.p2p_node_addr },
                |m: &mut Entry| { &mut m.p2p_node_addr },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::gossip::Heartbeat>(
                "raw_heartbeat",
                |m: &Entry| { &m.raw_heartbeat },
                |m: &mut Entry| { &mut m.raw_heartbeat },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entry>(
                "GetLastHeartbeatsResponse.Entry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Entry {
        const NAME: &'static str = "Entry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.verified_guardian_addr = is.read_string()?;
                    },
                    18 => {
                        self.p2p_node_addr = is.read_string()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.raw_heartbeat)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.verified_guardian_addr.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.verified_guardian_addr);
            }
            if !self.p2p_node_addr.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.p2p_node_addr);
            }
            if let Some(v) = self.raw_heartbeat.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.verified_guardian_addr.is_empty() {
                os.write_string(1, &self.verified_guardian_addr)?;
            }
            if !self.p2p_node_addr.is_empty() {
                os.write_string(2, &self.p2p_node_addr)?;
            }
            if let Some(v) = self.raw_heartbeat.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Entry {
            Entry::new()
        }

        fn clear(&mut self) {
            self.verified_guardian_addr.clear();
            self.p2p_node_addr.clear();
            self.raw_heartbeat.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Entry {
            static instance: Entry = Entry {
                verified_guardian_addr: ::std::string::String::new(),
                p2p_node_addr: ::std::string::String::new(),
                raw_heartbeat: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Entry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GetLastHeartbeatsResponse.Entry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Entry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Entry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GetCurrentGuardianSetRequest)
pub struct GetCurrentGuardianSetRequest {
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GetCurrentGuardianSetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCurrentGuardianSetRequest {
    fn default() -> &'a GetCurrentGuardianSetRequest {
        <GetCurrentGuardianSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentGuardianSetRequest {
    pub fn new() -> GetCurrentGuardianSetRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetCurrentGuardianSetRequest>(
            "GetCurrentGuardianSetRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetCurrentGuardianSetRequest {
    const NAME: &'static str = "GetCurrentGuardianSetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCurrentGuardianSetRequest {
        GetCurrentGuardianSetRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCurrentGuardianSetRequest {
        static instance: GetCurrentGuardianSetRequest = GetCurrentGuardianSetRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetCurrentGuardianSetRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetCurrentGuardianSetRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetCurrentGuardianSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentGuardianSetRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GetCurrentGuardianSetResponse)
pub struct GetCurrentGuardianSetResponse {
    // message fields
    // @@protoc_insertion_point(field:publicrpc.v1.GetCurrentGuardianSetResponse.guardian_set)
    pub guardian_set: ::protobuf::MessageField<GuardianSet>,
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GetCurrentGuardianSetResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCurrentGuardianSetResponse {
    fn default() -> &'a GetCurrentGuardianSetResponse {
        <GetCurrentGuardianSetResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentGuardianSetResponse {
    pub fn new() -> GetCurrentGuardianSetResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GuardianSet>(
            "guardian_set",
            |m: &GetCurrentGuardianSetResponse| { &m.guardian_set },
            |m: &mut GetCurrentGuardianSetResponse| { &mut m.guardian_set },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetCurrentGuardianSetResponse>(
            "GetCurrentGuardianSetResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetCurrentGuardianSetResponse {
    const NAME: &'static str = "GetCurrentGuardianSetResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.guardian_set)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guardian_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guardian_set.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCurrentGuardianSetResponse {
        GetCurrentGuardianSetResponse::new()
    }

    fn clear(&mut self) {
        self.guardian_set.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCurrentGuardianSetResponse {
        static instance: GetCurrentGuardianSetResponse = GetCurrentGuardianSetResponse {
            guardian_set: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetCurrentGuardianSetResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetCurrentGuardianSetResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetCurrentGuardianSetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentGuardianSetResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GuardianSet)
pub struct GuardianSet {
    // message fields
    // @@protoc_insertion_point(field:publicrpc.v1.GuardianSet.index)
    pub index: u32,
    // @@protoc_insertion_point(field:publicrpc.v1.GuardianSet.addresses)
    pub addresses: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GuardianSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GuardianSet {
    fn default() -> &'a GuardianSet {
        <GuardianSet as ::protobuf::Message>::default_instance()
    }
}

impl GuardianSet {
    pub fn new() -> GuardianSet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &GuardianSet| { &m.index },
            |m: &mut GuardianSet| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "addresses",
            |m: &GuardianSet| { &m.addresses },
            |m: &mut GuardianSet| { &mut m.addresses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GuardianSet>(
            "GuardianSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GuardianSet {
    const NAME: &'static str = "GuardianSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = is.read_uint32()?;
                },
                18 => {
                    self.addresses.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.index);
        }
        for value in &self.addresses {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.index != 0 {
            os.write_uint32(1, self.index)?;
        }
        for v in &self.addresses {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GuardianSet {
        GuardianSet::new()
    }

    fn clear(&mut self) {
        self.index = 0;
        self.addresses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GuardianSet {
        static instance: GuardianSet = GuardianSet {
            index: 0,
            addresses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GuardianSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GuardianSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GuardianSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GuardianSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GovernorGetAvailableNotionalByChainRequest)
pub struct GovernorGetAvailableNotionalByChainRequest {
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GovernorGetAvailableNotionalByChainRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GovernorGetAvailableNotionalByChainRequest {
    fn default() -> &'a GovernorGetAvailableNotionalByChainRequest {
        <GovernorGetAvailableNotionalByChainRequest as ::protobuf::Message>::default_instance()
    }
}

impl GovernorGetAvailableNotionalByChainRequest {
    pub fn new() -> GovernorGetAvailableNotionalByChainRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GovernorGetAvailableNotionalByChainRequest>(
            "GovernorGetAvailableNotionalByChainRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GovernorGetAvailableNotionalByChainRequest {
    const NAME: &'static str = "GovernorGetAvailableNotionalByChainRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GovernorGetAvailableNotionalByChainRequest {
        GovernorGetAvailableNotionalByChainRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GovernorGetAvailableNotionalByChainRequest {
        static instance: GovernorGetAvailableNotionalByChainRequest = GovernorGetAvailableNotionalByChainRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GovernorGetAvailableNotionalByChainRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GovernorGetAvailableNotionalByChainRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GovernorGetAvailableNotionalByChainRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorGetAvailableNotionalByChainRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GovernorGetAvailableNotionalByChainResponse)
pub struct GovernorGetAvailableNotionalByChainResponse {
    // message fields
    // @@protoc_insertion_point(field:publicrpc.v1.GovernorGetAvailableNotionalByChainResponse.entries)
    pub entries: ::std::vec::Vec<governor_get_available_notional_by_chain_response::Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GovernorGetAvailableNotionalByChainResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GovernorGetAvailableNotionalByChainResponse {
    fn default() -> &'a GovernorGetAvailableNotionalByChainResponse {
        <GovernorGetAvailableNotionalByChainResponse as ::protobuf::Message>::default_instance()
    }
}

impl GovernorGetAvailableNotionalByChainResponse {
    pub fn new() -> GovernorGetAvailableNotionalByChainResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &GovernorGetAvailableNotionalByChainResponse| { &m.entries },
            |m: &mut GovernorGetAvailableNotionalByChainResponse| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GovernorGetAvailableNotionalByChainResponse>(
            "GovernorGetAvailableNotionalByChainResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GovernorGetAvailableNotionalByChainResponse {
    const NAME: &'static str = "GovernorGetAvailableNotionalByChainResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GovernorGetAvailableNotionalByChainResponse {
        GovernorGetAvailableNotionalByChainResponse::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GovernorGetAvailableNotionalByChainResponse {
        static instance: GovernorGetAvailableNotionalByChainResponse = GovernorGetAvailableNotionalByChainResponse {
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GovernorGetAvailableNotionalByChainResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GovernorGetAvailableNotionalByChainResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GovernorGetAvailableNotionalByChainResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorGetAvailableNotionalByChainResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GovernorGetAvailableNotionalByChainResponse`
pub mod governor_get_available_notional_by_chain_response {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:publicrpc.v1.GovernorGetAvailableNotionalByChainResponse.Entry)
    pub struct Entry {
        // message fields
        // @@protoc_insertion_point(field:publicrpc.v1.GovernorGetAvailableNotionalByChainResponse.Entry.chain_id)
        pub chain_id: u32,
        // @@protoc_insertion_point(field:publicrpc.v1.GovernorGetAvailableNotionalByChainResponse.Entry.remaining_available_notional)
        pub remaining_available_notional: u64,
        // @@protoc_insertion_point(field:publicrpc.v1.GovernorGetAvailableNotionalByChainResponse.Entry.notional_limit)
        pub notional_limit: u64,
        // @@protoc_insertion_point(field:publicrpc.v1.GovernorGetAvailableNotionalByChainResponse.Entry.big_transaction_size)
        pub big_transaction_size: u64,
        // special fields
        // @@protoc_insertion_point(special_field:publicrpc.v1.GovernorGetAvailableNotionalByChainResponse.Entry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Entry {
        fn default() -> &'a Entry {
            <Entry as ::protobuf::Message>::default_instance()
        }
    }

    impl Entry {
        pub fn new() -> Entry {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "chain_id",
                |m: &Entry| { &m.chain_id },
                |m: &mut Entry| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "remaining_available_notional",
                |m: &Entry| { &m.remaining_available_notional },
                |m: &mut Entry| { &mut m.remaining_available_notional },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "notional_limit",
                |m: &Entry| { &m.notional_limit },
                |m: &mut Entry| { &mut m.notional_limit },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "big_transaction_size",
                |m: &Entry| { &m.big_transaction_size },
                |m: &mut Entry| { &mut m.big_transaction_size },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entry>(
                "GovernorGetAvailableNotionalByChainResponse.Entry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Entry {
        const NAME: &'static str = "Entry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.chain_id = is.read_uint32()?;
                    },
                    16 => {
                        self.remaining_available_notional = is.read_uint64()?;
                    },
                    24 => {
                        self.notional_limit = is.read_uint64()?;
                    },
                    32 => {
                        self.big_transaction_size = is.read_uint64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.chain_id != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.chain_id);
            }
            if self.remaining_available_notional != 0 {
                my_size += ::protobuf::rt::uint64_size(2, self.remaining_available_notional);
            }
            if self.notional_limit != 0 {
                my_size += ::protobuf::rt::uint64_size(3, self.notional_limit);
            }
            if self.big_transaction_size != 0 {
                my_size += ::protobuf::rt::uint64_size(4, self.big_transaction_size);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.chain_id != 0 {
                os.write_uint32(1, self.chain_id)?;
            }
            if self.remaining_available_notional != 0 {
                os.write_uint64(2, self.remaining_available_notional)?;
            }
            if self.notional_limit != 0 {
                os.write_uint64(3, self.notional_limit)?;
            }
            if self.big_transaction_size != 0 {
                os.write_uint64(4, self.big_transaction_size)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Entry {
            Entry::new()
        }

        fn clear(&mut self) {
            self.chain_id = 0;
            self.remaining_available_notional = 0;
            self.notional_limit = 0;
            self.big_transaction_size = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Entry {
            static instance: Entry = Entry {
                chain_id: 0,
                remaining_available_notional: 0,
                notional_limit: 0,
                big_transaction_size: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Entry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GovernorGetAvailableNotionalByChainResponse.Entry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Entry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Entry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GovernorGetEnqueuedVAAsRequest)
pub struct GovernorGetEnqueuedVAAsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GovernorGetEnqueuedVAAsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GovernorGetEnqueuedVAAsRequest {
    fn default() -> &'a GovernorGetEnqueuedVAAsRequest {
        <GovernorGetEnqueuedVAAsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GovernorGetEnqueuedVAAsRequest {
    pub fn new() -> GovernorGetEnqueuedVAAsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GovernorGetEnqueuedVAAsRequest>(
            "GovernorGetEnqueuedVAAsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GovernorGetEnqueuedVAAsRequest {
    const NAME: &'static str = "GovernorGetEnqueuedVAAsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GovernorGetEnqueuedVAAsRequest {
        GovernorGetEnqueuedVAAsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GovernorGetEnqueuedVAAsRequest {
        static instance: GovernorGetEnqueuedVAAsRequest = GovernorGetEnqueuedVAAsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GovernorGetEnqueuedVAAsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GovernorGetEnqueuedVAAsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GovernorGetEnqueuedVAAsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorGetEnqueuedVAAsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GovernorGetEnqueuedVAAsResponse)
pub struct GovernorGetEnqueuedVAAsResponse {
    // message fields
    // @@protoc_insertion_point(field:publicrpc.v1.GovernorGetEnqueuedVAAsResponse.entries)
    pub entries: ::std::vec::Vec<governor_get_enqueued_vaas_response::Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GovernorGetEnqueuedVAAsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GovernorGetEnqueuedVAAsResponse {
    fn default() -> &'a GovernorGetEnqueuedVAAsResponse {
        <GovernorGetEnqueuedVAAsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GovernorGetEnqueuedVAAsResponse {
    pub fn new() -> GovernorGetEnqueuedVAAsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &GovernorGetEnqueuedVAAsResponse| { &m.entries },
            |m: &mut GovernorGetEnqueuedVAAsResponse| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GovernorGetEnqueuedVAAsResponse>(
            "GovernorGetEnqueuedVAAsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GovernorGetEnqueuedVAAsResponse {
    const NAME: &'static str = "GovernorGetEnqueuedVAAsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GovernorGetEnqueuedVAAsResponse {
        GovernorGetEnqueuedVAAsResponse::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GovernorGetEnqueuedVAAsResponse {
        static instance: GovernorGetEnqueuedVAAsResponse = GovernorGetEnqueuedVAAsResponse {
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GovernorGetEnqueuedVAAsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GovernorGetEnqueuedVAAsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GovernorGetEnqueuedVAAsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorGetEnqueuedVAAsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GovernorGetEnqueuedVAAsResponse`
pub mod governor_get_enqueued_vaas_response {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:publicrpc.v1.GovernorGetEnqueuedVAAsResponse.Entry)
    pub struct Entry {
        // message fields
        // @@protoc_insertion_point(field:publicrpc.v1.GovernorGetEnqueuedVAAsResponse.Entry.emitter_chain)
        pub emitter_chain: u32,
        // @@protoc_insertion_point(field:publicrpc.v1.GovernorGetEnqueuedVAAsResponse.Entry.emitter_address)
        pub emitter_address: ::std::string::String,
        // @@protoc_insertion_point(field:publicrpc.v1.GovernorGetEnqueuedVAAsResponse.Entry.sequence)
        pub sequence: u64,
        // @@protoc_insertion_point(field:publicrpc.v1.GovernorGetEnqueuedVAAsResponse.Entry.release_time)
        pub release_time: u32,
        // @@protoc_insertion_point(field:publicrpc.v1.GovernorGetEnqueuedVAAsResponse.Entry.notional_value)
        pub notional_value: u64,
        // @@protoc_insertion_point(field:publicrpc.v1.GovernorGetEnqueuedVAAsResponse.Entry.tx_hash)
        pub tx_hash: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:publicrpc.v1.GovernorGetEnqueuedVAAsResponse.Entry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Entry {
        fn default() -> &'a Entry {
            <Entry as ::protobuf::Message>::default_instance()
        }
    }

    impl Entry {
        pub fn new() -> Entry {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "emitter_chain",
                |m: &Entry| { &m.emitter_chain },
                |m: &mut Entry| { &mut m.emitter_chain },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "emitter_address",
                |m: &Entry| { &m.emitter_address },
                |m: &mut Entry| { &mut m.emitter_address },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "sequence",
                |m: &Entry| { &m.sequence },
                |m: &mut Entry| { &mut m.sequence },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "release_time",
                |m: &Entry| { &m.release_time },
                |m: &mut Entry| { &mut m.release_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "notional_value",
                |m: &Entry| { &m.notional_value },
                |m: &mut Entry| { &mut m.notional_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "tx_hash",
                |m: &Entry| { &m.tx_hash },
                |m: &mut Entry| { &mut m.tx_hash },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entry>(
                "GovernorGetEnqueuedVAAsResponse.Entry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Entry {
        const NAME: &'static str = "Entry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.emitter_chain = is.read_uint32()?;
                    },
                    18 => {
                        self.emitter_address = is.read_string()?;
                    },
                    24 => {
                        self.sequence = is.read_uint64()?;
                    },
                    32 => {
                        self.release_time = is.read_uint32()?;
                    },
                    40 => {
                        self.notional_value = is.read_uint64()?;
                    },
                    50 => {
                        self.tx_hash = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.emitter_chain != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.emitter_chain);
            }
            if !self.emitter_address.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.emitter_address);
            }
            if self.sequence != 0 {
                my_size += ::protobuf::rt::uint64_size(3, self.sequence);
            }
            if self.release_time != 0 {
                my_size += ::protobuf::rt::uint32_size(4, self.release_time);
            }
            if self.notional_value != 0 {
                my_size += ::protobuf::rt::uint64_size(5, self.notional_value);
            }
            if !self.tx_hash.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.tx_hash);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.emitter_chain != 0 {
                os.write_uint32(1, self.emitter_chain)?;
            }
            if !self.emitter_address.is_empty() {
                os.write_string(2, &self.emitter_address)?;
            }
            if self.sequence != 0 {
                os.write_uint64(3, self.sequence)?;
            }
            if self.release_time != 0 {
                os.write_uint32(4, self.release_time)?;
            }
            if self.notional_value != 0 {
                os.write_uint64(5, self.notional_value)?;
            }
            if !self.tx_hash.is_empty() {
                os.write_string(6, &self.tx_hash)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Entry {
            Entry::new()
        }

        fn clear(&mut self) {
            self.emitter_chain = 0;
            self.emitter_address.clear();
            self.sequence = 0;
            self.release_time = 0;
            self.notional_value = 0;
            self.tx_hash.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Entry {
            static instance: Entry = Entry {
                emitter_chain: 0,
                emitter_address: ::std::string::String::new(),
                sequence: 0,
                release_time: 0,
                notional_value: 0,
                tx_hash: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Entry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GovernorGetEnqueuedVAAsResponse.Entry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Entry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Entry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GovernorIsVAAEnqueuedRequest)
pub struct GovernorIsVAAEnqueuedRequest {
    // message fields
    // @@protoc_insertion_point(field:publicrpc.v1.GovernorIsVAAEnqueuedRequest.message_id)
    pub message_id: ::protobuf::MessageField<MessageID>,
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GovernorIsVAAEnqueuedRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GovernorIsVAAEnqueuedRequest {
    fn default() -> &'a GovernorIsVAAEnqueuedRequest {
        <GovernorIsVAAEnqueuedRequest as ::protobuf::Message>::default_instance()
    }
}

impl GovernorIsVAAEnqueuedRequest {
    pub fn new() -> GovernorIsVAAEnqueuedRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageID>(
            "message_id",
            |m: &GovernorIsVAAEnqueuedRequest| { &m.message_id },
            |m: &mut GovernorIsVAAEnqueuedRequest| { &mut m.message_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GovernorIsVAAEnqueuedRequest>(
            "GovernorIsVAAEnqueuedRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GovernorIsVAAEnqueuedRequest {
    const NAME: &'static str = "GovernorIsVAAEnqueuedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GovernorIsVAAEnqueuedRequest {
        GovernorIsVAAEnqueuedRequest::new()
    }

    fn clear(&mut self) {
        self.message_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GovernorIsVAAEnqueuedRequest {
        static instance: GovernorIsVAAEnqueuedRequest = GovernorIsVAAEnqueuedRequest {
            message_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GovernorIsVAAEnqueuedRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GovernorIsVAAEnqueuedRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GovernorIsVAAEnqueuedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorIsVAAEnqueuedRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GovernorIsVAAEnqueuedResponse)
pub struct GovernorIsVAAEnqueuedResponse {
    // message fields
    // @@protoc_insertion_point(field:publicrpc.v1.GovernorIsVAAEnqueuedResponse.is_enqueued)
    pub is_enqueued: bool,
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GovernorIsVAAEnqueuedResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GovernorIsVAAEnqueuedResponse {
    fn default() -> &'a GovernorIsVAAEnqueuedResponse {
        <GovernorIsVAAEnqueuedResponse as ::protobuf::Message>::default_instance()
    }
}

impl GovernorIsVAAEnqueuedResponse {
    pub fn new() -> GovernorIsVAAEnqueuedResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_enqueued",
            |m: &GovernorIsVAAEnqueuedResponse| { &m.is_enqueued },
            |m: &mut GovernorIsVAAEnqueuedResponse| { &mut m.is_enqueued },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GovernorIsVAAEnqueuedResponse>(
            "GovernorIsVAAEnqueuedResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GovernorIsVAAEnqueuedResponse {
    const NAME: &'static str = "GovernorIsVAAEnqueuedResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_enqueued = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.is_enqueued != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.is_enqueued != false {
            os.write_bool(1, self.is_enqueued)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GovernorIsVAAEnqueuedResponse {
        GovernorIsVAAEnqueuedResponse::new()
    }

    fn clear(&mut self) {
        self.is_enqueued = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GovernorIsVAAEnqueuedResponse {
        static instance: GovernorIsVAAEnqueuedResponse = GovernorIsVAAEnqueuedResponse {
            is_enqueued: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GovernorIsVAAEnqueuedResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GovernorIsVAAEnqueuedResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GovernorIsVAAEnqueuedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorIsVAAEnqueuedResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GovernorGetTokenListRequest)
pub struct GovernorGetTokenListRequest {
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GovernorGetTokenListRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GovernorGetTokenListRequest {
    fn default() -> &'a GovernorGetTokenListRequest {
        <GovernorGetTokenListRequest as ::protobuf::Message>::default_instance()
    }
}

impl GovernorGetTokenListRequest {
    pub fn new() -> GovernorGetTokenListRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GovernorGetTokenListRequest>(
            "GovernorGetTokenListRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GovernorGetTokenListRequest {
    const NAME: &'static str = "GovernorGetTokenListRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GovernorGetTokenListRequest {
        GovernorGetTokenListRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GovernorGetTokenListRequest {
        static instance: GovernorGetTokenListRequest = GovernorGetTokenListRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GovernorGetTokenListRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GovernorGetTokenListRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GovernorGetTokenListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorGetTokenListRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:publicrpc.v1.GovernorGetTokenListResponse)
pub struct GovernorGetTokenListResponse {
    // message fields
    // @@protoc_insertion_point(field:publicrpc.v1.GovernorGetTokenListResponse.entries)
    pub entries: ::std::vec::Vec<governor_get_token_list_response::Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:publicrpc.v1.GovernorGetTokenListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GovernorGetTokenListResponse {
    fn default() -> &'a GovernorGetTokenListResponse {
        <GovernorGetTokenListResponse as ::protobuf::Message>::default_instance()
    }
}

impl GovernorGetTokenListResponse {
    pub fn new() -> GovernorGetTokenListResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &GovernorGetTokenListResponse| { &m.entries },
            |m: &mut GovernorGetTokenListResponse| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GovernorGetTokenListResponse>(
            "GovernorGetTokenListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GovernorGetTokenListResponse {
    const NAME: &'static str = "GovernorGetTokenListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GovernorGetTokenListResponse {
        GovernorGetTokenListResponse::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GovernorGetTokenListResponse {
        static instance: GovernorGetTokenListResponse = GovernorGetTokenListResponse {
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GovernorGetTokenListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GovernorGetTokenListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GovernorGetTokenListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GovernorGetTokenListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GovernorGetTokenListResponse`
pub mod governor_get_token_list_response {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:publicrpc.v1.GovernorGetTokenListResponse.Entry)
    pub struct Entry {
        // message fields
        // @@protoc_insertion_point(field:publicrpc.v1.GovernorGetTokenListResponse.Entry.origin_chain_id)
        pub origin_chain_id: u32,
        // @@protoc_insertion_point(field:publicrpc.v1.GovernorGetTokenListResponse.Entry.origin_address)
        pub origin_address: ::std::string::String,
        // @@protoc_insertion_point(field:publicrpc.v1.GovernorGetTokenListResponse.Entry.price)
        pub price: f32,
        // special fields
        // @@protoc_insertion_point(special_field:publicrpc.v1.GovernorGetTokenListResponse.Entry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Entry {
        fn default() -> &'a Entry {
            <Entry as ::protobuf::Message>::default_instance()
        }
    }

    impl Entry {
        pub fn new() -> Entry {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "origin_chain_id",
                |m: &Entry| { &m.origin_chain_id },
                |m: &mut Entry| { &mut m.origin_chain_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "origin_address",
                |m: &Entry| { &m.origin_address },
                |m: &mut Entry| { &mut m.origin_address },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "price",
                |m: &Entry| { &m.price },
                |m: &mut Entry| { &mut m.price },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entry>(
                "GovernorGetTokenListResponse.Entry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Entry {
        const NAME: &'static str = "Entry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.origin_chain_id = is.read_uint32()?;
                    },
                    18 => {
                        self.origin_address = is.read_string()?;
                    },
                    29 => {
                        self.price = is.read_float()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.origin_chain_id != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.origin_chain_id);
            }
            if !self.origin_address.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.origin_address);
            }
            if self.price != 0. {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.origin_chain_id != 0 {
                os.write_uint32(1, self.origin_chain_id)?;
            }
            if !self.origin_address.is_empty() {
                os.write_string(2, &self.origin_address)?;
            }
            if self.price != 0. {
                os.write_float(3, self.price)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Entry {
            Entry::new()
        }

        fn clear(&mut self) {
            self.origin_chain_id = 0;
            self.origin_address.clear();
            self.price = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Entry {
            static instance: Entry = Entry {
                origin_chain_id: 0,
                origin_address: ::std::string::String::new(),
                price: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Entry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GovernorGetTokenListResponse.Entry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Entry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Entry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:publicrpc.v1.ChainID)
pub enum ChainID {
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_UNSPECIFIED)
    CHAIN_ID_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_SOLANA)
    CHAIN_ID_SOLANA = 1,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_ETHEREUM)
    CHAIN_ID_ETHEREUM = 2,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_TERRA)
    CHAIN_ID_TERRA = 3,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_BSC)
    CHAIN_ID_BSC = 4,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_POLYGON)
    CHAIN_ID_POLYGON = 5,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_AVALANCHE)
    CHAIN_ID_AVALANCHE = 6,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_OASIS)
    CHAIN_ID_OASIS = 7,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_ALGORAND)
    CHAIN_ID_ALGORAND = 8,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_AURORA)
    CHAIN_ID_AURORA = 9,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_FANTOM)
    CHAIN_ID_FANTOM = 10,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_KARURA)
    CHAIN_ID_KARURA = 11,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_ACALA)
    CHAIN_ID_ACALA = 12,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_KLAYTN)
    CHAIN_ID_KLAYTN = 13,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_CELO)
    CHAIN_ID_CELO = 14,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_NEAR)
    CHAIN_ID_NEAR = 15,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_MOONBEAM)
    CHAIN_ID_MOONBEAM = 16,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_NEON)
    CHAIN_ID_NEON = 17,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_TERRA2)
    CHAIN_ID_TERRA2 = 18,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_INJECTIVE)
    CHAIN_ID_INJECTIVE = 19,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_OSMOSIS)
    CHAIN_ID_OSMOSIS = 20,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_SUI)
    CHAIN_ID_SUI = 21,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_APTOS)
    CHAIN_ID_APTOS = 22,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_ARBITRUM)
    CHAIN_ID_ARBITRUM = 23,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_OPTIMISM)
    CHAIN_ID_OPTIMISM = 24,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_GNOSIS)
    CHAIN_ID_GNOSIS = 25,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_PYTHNET)
    CHAIN_ID_PYTHNET = 26,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_XPLA)
    CHAIN_ID_XPLA = 28,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_BTC)
    CHAIN_ID_BTC = 29,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_BASE)
    CHAIN_ID_BASE = 30,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_SEI)
    CHAIN_ID_SEI = 32,
    // @@protoc_insertion_point(enum_value:publicrpc.v1.ChainID.CHAIN_ID_SEPOLIA)
    CHAIN_ID_SEPOLIA = 10002,
}

impl ::protobuf::Enum for ChainID {
    const NAME: &'static str = "ChainID";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChainID> {
        match value {
            0 => ::std::option::Option::Some(ChainID::CHAIN_ID_UNSPECIFIED),
            1 => ::std::option::Option::Some(ChainID::CHAIN_ID_SOLANA),
            2 => ::std::option::Option::Some(ChainID::CHAIN_ID_ETHEREUM),
            3 => ::std::option::Option::Some(ChainID::CHAIN_ID_TERRA),
            4 => ::std::option::Option::Some(ChainID::CHAIN_ID_BSC),
            5 => ::std::option::Option::Some(ChainID::CHAIN_ID_POLYGON),
            6 => ::std::option::Option::Some(ChainID::CHAIN_ID_AVALANCHE),
            7 => ::std::option::Option::Some(ChainID::CHAIN_ID_OASIS),
            8 => ::std::option::Option::Some(ChainID::CHAIN_ID_ALGORAND),
            9 => ::std::option::Option::Some(ChainID::CHAIN_ID_AURORA),
            10 => ::std::option::Option::Some(ChainID::CHAIN_ID_FANTOM),
            11 => ::std::option::Option::Some(ChainID::CHAIN_ID_KARURA),
            12 => ::std::option::Option::Some(ChainID::CHAIN_ID_ACALA),
            13 => ::std::option::Option::Some(ChainID::CHAIN_ID_KLAYTN),
            14 => ::std::option::Option::Some(ChainID::CHAIN_ID_CELO),
            15 => ::std::option::Option::Some(ChainID::CHAIN_ID_NEAR),
            16 => ::std::option::Option::Some(ChainID::CHAIN_ID_MOONBEAM),
            17 => ::std::option::Option::Some(ChainID::CHAIN_ID_NEON),
            18 => ::std::option::Option::Some(ChainID::CHAIN_ID_TERRA2),
            19 => ::std::option::Option::Some(ChainID::CHAIN_ID_INJECTIVE),
            20 => ::std::option::Option::Some(ChainID::CHAIN_ID_OSMOSIS),
            21 => ::std::option::Option::Some(ChainID::CHAIN_ID_SUI),
            22 => ::std::option::Option::Some(ChainID::CHAIN_ID_APTOS),
            23 => ::std::option::Option::Some(ChainID::CHAIN_ID_ARBITRUM),
            24 => ::std::option::Option::Some(ChainID::CHAIN_ID_OPTIMISM),
            25 => ::std::option::Option::Some(ChainID::CHAIN_ID_GNOSIS),
            26 => ::std::option::Option::Some(ChainID::CHAIN_ID_PYTHNET),
            28 => ::std::option::Option::Some(ChainID::CHAIN_ID_XPLA),
            29 => ::std::option::Option::Some(ChainID::CHAIN_ID_BTC),
            30 => ::std::option::Option::Some(ChainID::CHAIN_ID_BASE),
            32 => ::std::option::Option::Some(ChainID::CHAIN_ID_SEI),
            10002 => ::std::option::Option::Some(ChainID::CHAIN_ID_SEPOLIA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ChainID] = &[
        ChainID::CHAIN_ID_UNSPECIFIED,
        ChainID::CHAIN_ID_SOLANA,
        ChainID::CHAIN_ID_ETHEREUM,
        ChainID::CHAIN_ID_TERRA,
        ChainID::CHAIN_ID_BSC,
        ChainID::CHAIN_ID_POLYGON,
        ChainID::CHAIN_ID_AVALANCHE,
        ChainID::CHAIN_ID_OASIS,
        ChainID::CHAIN_ID_ALGORAND,
        ChainID::CHAIN_ID_AURORA,
        ChainID::CHAIN_ID_FANTOM,
        ChainID::CHAIN_ID_KARURA,
        ChainID::CHAIN_ID_ACALA,
        ChainID::CHAIN_ID_KLAYTN,
        ChainID::CHAIN_ID_CELO,
        ChainID::CHAIN_ID_NEAR,
        ChainID::CHAIN_ID_MOONBEAM,
        ChainID::CHAIN_ID_NEON,
        ChainID::CHAIN_ID_TERRA2,
        ChainID::CHAIN_ID_INJECTIVE,
        ChainID::CHAIN_ID_OSMOSIS,
        ChainID::CHAIN_ID_SUI,
        ChainID::CHAIN_ID_APTOS,
        ChainID::CHAIN_ID_ARBITRUM,
        ChainID::CHAIN_ID_OPTIMISM,
        ChainID::CHAIN_ID_GNOSIS,
        ChainID::CHAIN_ID_PYTHNET,
        ChainID::CHAIN_ID_XPLA,
        ChainID::CHAIN_ID_BTC,
        ChainID::CHAIN_ID_BASE,
        ChainID::CHAIN_ID_SEI,
        ChainID::CHAIN_ID_SEPOLIA,
    ];
}

impl ::protobuf::EnumFull for ChainID {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ChainID").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ChainID::CHAIN_ID_UNSPECIFIED => 0,
            ChainID::CHAIN_ID_SOLANA => 1,
            ChainID::CHAIN_ID_ETHEREUM => 2,
            ChainID::CHAIN_ID_TERRA => 3,
            ChainID::CHAIN_ID_BSC => 4,
            ChainID::CHAIN_ID_POLYGON => 5,
            ChainID::CHAIN_ID_AVALANCHE => 6,
            ChainID::CHAIN_ID_OASIS => 7,
            ChainID::CHAIN_ID_ALGORAND => 8,
            ChainID::CHAIN_ID_AURORA => 9,
            ChainID::CHAIN_ID_FANTOM => 10,
            ChainID::CHAIN_ID_KARURA => 11,
            ChainID::CHAIN_ID_ACALA => 12,
            ChainID::CHAIN_ID_KLAYTN => 13,
            ChainID::CHAIN_ID_CELO => 14,
            ChainID::CHAIN_ID_NEAR => 15,
            ChainID::CHAIN_ID_MOONBEAM => 16,
            ChainID::CHAIN_ID_NEON => 17,
            ChainID::CHAIN_ID_TERRA2 => 18,
            ChainID::CHAIN_ID_INJECTIVE => 19,
            ChainID::CHAIN_ID_OSMOSIS => 20,
            ChainID::CHAIN_ID_SUI => 21,
            ChainID::CHAIN_ID_APTOS => 22,
            ChainID::CHAIN_ID_ARBITRUM => 23,
            ChainID::CHAIN_ID_OPTIMISM => 24,
            ChainID::CHAIN_ID_GNOSIS => 25,
            ChainID::CHAIN_ID_PYTHNET => 26,
            ChainID::CHAIN_ID_XPLA => 27,
            ChainID::CHAIN_ID_BTC => 28,
            ChainID::CHAIN_ID_BASE => 29,
            ChainID::CHAIN_ID_SEI => 30,
            ChainID::CHAIN_ID_SEPOLIA => 31,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ChainID {
    fn default() -> Self {
        ChainID::CHAIN_ID_UNSPECIFIED
    }
}

impl ChainID {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ChainID>("ChainID")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cpublicrpc/v1/publicrpc.proto\x12\x0cpublicrpc.v1\x1a\x16gossip/v1/\
    gossip.proto\x1a\x1cgoogle/api/annotations.proto\"\x8c\x01\n\tMessageID\
    \x12:\n\remitter_chain\x18\x01\x20\x01(\x0e2\x15.publicrpc.v1.ChainIDR\
    \x0cemitterChain\x12'\n\x0femitter_address\x18\x02\x20\x01(\tR\x0eemitte\
    rAddress\x12\x1a\n\x08sequence\x18\x03\x20\x01(\x04R\x08sequence\"p\n\
    \x07BatchID\x12:\n\remitter_chain\x18\x01\x20\x01(\x0e2\x15.publicrpc.v1\
    .ChainIDR\x0cemitterChain\x12\x13\n\x05tx_id\x18\x02\x20\x01(\x0cR\x04tx\
    Id\x12\x14\n\x05nonce\x18\x03\x20\x01(\rR\x05nonce\"M\n\x13GetSignedVAAR\
    equest\x126\n\nmessage_id\x18\x01\x20\x01(\x0b2\x17.publicrpc.v1.Message\
    IDR\tmessageId\"3\n\x14GetSignedVAAResponse\x12\x1b\n\tvaa_bytes\x18\x01\
    \x20\x01(\x0cR\x08vaaBytes\"L\n\x18GetSignedBatchVAARequest\x120\n\x08ba\
    tch_id\x18\x01\x20\x01(\x0b2\x15.publicrpc.v1.BatchIDR\x07batchId\"j\n\
    \x19GetSignedBatchVAAResponse\x12M\n\x10signed_batch_vaa\x18\x01\x20\x01\
    (\x0b2#.gossip.v1.SignedBatchVAAWithQuorumR\x0esignedBatchVaa\"\x1a\n\
    \x18GetLastHeartbeatsRequest\"\x83\x02\n\x19GetLastHeartbeatsResponse\
    \x12G\n\x07entries\x18\x01\x20\x03(\x0b2-.publicrpc.v1.GetLastHeartbeats\
    Response.EntryR\x07entries\x1a\x9c\x01\n\x05Entry\x124\n\x16verified_gua\
    rdian_addr\x18\x01\x20\x01(\tR\x14verifiedGuardianAddr\x12\"\n\rp2p_node\
    _addr\x18\x02\x20\x01(\tR\x0bp2pNodeAddr\x129\n\rraw_heartbeat\x18\x03\
    \x20\x01(\x0b2\x14.gossip.v1.HeartbeatR\x0crawHeartbeat\"\x1e\n\x1cGetCu\
    rrentGuardianSetRequest\"]\n\x1dGetCurrentGuardianSetResponse\x12<\n\x0c\
    guardian_set\x18\x01\x20\x01(\x0b2\x19.publicrpc.v1.GuardianSetR\x0bguar\
    dianSet\"A\n\x0bGuardianSet\x12\x14\n\x05index\x18\x01\x20\x01(\rR\x05in\
    dex\x12\x1c\n\taddresses\x18\x02\x20\x03(\tR\taddresses\",\n*GovernorGet\
    AvailableNotionalByChainRequest\"\xc8\x02\n+GovernorGetAvailableNotional\
    ByChainResponse\x12Y\n\x07entries\x18\x01\x20\x03(\x0b2?.publicrpc.v1.Go\
    vernorGetAvailableNotionalByChainResponse.EntryR\x07entries\x1a\xbd\x01\
    \n\x05Entry\x12\x19\n\x08chain_id\x18\x01\x20\x01(\rR\x07chainId\x12@\n\
    \x1cremaining_available_notional\x18\x02\x20\x01(\x04R\x1aremainingAvail\
    ableNotional\x12%\n\x0enotional_limit\x18\x03\x20\x01(\x04R\rnotionalLim\
    it\x120\n\x14big_transaction_size\x18\x04\x20\x01(\x04R\x12bigTransactio\
    nSize\"\x20\n\x1eGovernorGetEnqueuedVAAsRequest\"\xc7\x02\n\x1fGovernorG\
    etEnqueuedVAAsResponse\x12M\n\x07entries\x18\x01\x20\x03(\x0b23.publicrp\
    c.v1.GovernorGetEnqueuedVAAsResponse.EntryR\x07entries\x1a\xd4\x01\n\x05\
    Entry\x12#\n\remitter_chain\x18\x01\x20\x01(\rR\x0cemitterChain\x12'\n\
    \x0femitter_address\x18\x02\x20\x01(\tR\x0eemitterAddress\x12\x1a\n\x08s\
    equence\x18\x03\x20\x01(\x04R\x08sequence\x12!\n\x0crelease_time\x18\x04\
    \x20\x01(\rR\x0breleaseTime\x12%\n\x0enotional_value\x18\x05\x20\x01(\
    \x04R\rnotionalValue\x12\x17\n\x07tx_hash\x18\x06\x20\x01(\tR\x06txHash\
    \"V\n\x1cGovernorIsVAAEnqueuedRequest\x126\n\nmessage_id\x18\x01\x20\x01\
    (\x0b2\x17.publicrpc.v1.MessageIDR\tmessageId\"@\n\x1dGovernorIsVAAEnque\
    uedResponse\x12\x1f\n\x0bis_enqueued\x18\x01\x20\x01(\x08R\nisEnqueued\"\
    \x1d\n\x1bGovernorGetTokenListRequest\"\xd8\x01\n\x1cGovernorGetTokenLis\
    tResponse\x12J\n\x07entries\x18\x01\x20\x03(\x0b20.publicrpc.v1.Governor\
    GetTokenListResponse.EntryR\x07entries\x1al\n\x05Entry\x12&\n\x0forigin_\
    chain_id\x18\x01\x20\x01(\rR\roriginChainId\x12%\n\x0eorigin_address\x18\
    \x02\x20\x01(\tR\roriginAddress\x12\x14\n\x05price\x18\x03\x20\x01(\x02R\
    \x05price*\xa9\x05\n\x07ChainID\x12\x18\n\x14CHAIN_ID_UNSPECIFIED\x10\0\
    \x12\x13\n\x0fCHAIN_ID_SOLANA\x10\x01\x12\x15\n\x11CHAIN_ID_ETHEREUM\x10\
    \x02\x12\x12\n\x0eCHAIN_ID_TERRA\x10\x03\x12\x10\n\x0cCHAIN_ID_BSC\x10\
    \x04\x12\x14\n\x10CHAIN_ID_POLYGON\x10\x05\x12\x16\n\x12CHAIN_ID_AVALANC\
    HE\x10\x06\x12\x12\n\x0eCHAIN_ID_OASIS\x10\x07\x12\x15\n\x11CHAIN_ID_ALG\
    ORAND\x10\x08\x12\x13\n\x0fCHAIN_ID_AURORA\x10\t\x12\x13\n\x0fCHAIN_ID_F\
    ANTOM\x10\n\x12\x13\n\x0fCHAIN_ID_KARURA\x10\x0b\x12\x12\n\x0eCHAIN_ID_A\
    CALA\x10\x0c\x12\x13\n\x0fCHAIN_ID_KLAYTN\x10\r\x12\x11\n\rCHAIN_ID_CELO\
    \x10\x0e\x12\x11\n\rCHAIN_ID_NEAR\x10\x0f\x12\x15\n\x11CHAIN_ID_MOONBEAM\
    \x10\x10\x12\x11\n\rCHAIN_ID_NEON\x10\x11\x12\x13\n\x0fCHAIN_ID_TERRA2\
    \x10\x12\x12\x16\n\x12CHAIN_ID_INJECTIVE\x10\x13\x12\x14\n\x10CHAIN_ID_O\
    SMOSIS\x10\x14\x12\x10\n\x0cCHAIN_ID_SUI\x10\x15\x12\x12\n\x0eCHAIN_ID_A\
    PTOS\x10\x16\x12\x15\n\x11CHAIN_ID_ARBITRUM\x10\x17\x12\x15\n\x11CHAIN_I\
    D_OPTIMISM\x10\x18\x12\x13\n\x0fCHAIN_ID_GNOSIS\x10\x19\x12\x14\n\x10CHA\
    IN_ID_PYTHNET\x10\x1a\x12\x11\n\rCHAIN_ID_XPLA\x10\x1c\x12\x10\n\x0cCHAI\
    N_ID_BTC\x10\x1d\x12\x11\n\rCHAIN_ID_BASE\x10\x1e\x12\x10\n\x0cCHAIN_ID_\
    SEI\x10\x20\x12\x15\n\x10CHAIN_ID_SEPOLIA\x10\x92N2\x86\x0b\n\x10PublicR\
    PCService\x12|\n\x11GetLastHeartbeats\x12&.publicrpc.v1.GetLastHeartbeat\
    sRequest\x1a'.publicrpc.v1.GetLastHeartbeatsResponse\"\x16\x82\xd3\xe4\
    \x93\x02\x10\x12\x0e/v1/heartbeats\x12\xbb\x01\n\x0cGetSignedVAA\x12!.pu\
    blicrpc.v1.GetSignedVAARequest\x1a\".publicrpc.v1.GetSignedVAAResponse\"\
    d\x82\xd3\xe4\x93\x02^\x12\\/v1/signed_vaa/{message_id.emitter_chain}/{m\
    essage_id.emitter_address}/{message_id.sequence}\x12\xbd\x01\n\x11GetSig\
    nedBatchVAA\x12&.publicrpc.v1.GetSignedBatchVAARequest\x1a'.publicrpc.v1\
    .GetSignedBatchVAAResponse\"W\x82\xd3\xe4\x93\x02Q\x12O/v1/signed_batch_\
    vaa/{batch_id.emitter_chain}/{batch_id.tx_id}/{batch_id.nonce}\x12\x91\
    \x01\n\x15GetCurrentGuardianSet\x12*.publicrpc.v1.GetCurrentGuardianSetR\
    equest\x1a+.publicrpc.v1.GetCurrentGuardianSetResponse\"\x1f\x82\xd3\xe4\
    \x93\x02\x19\x12\x17/v1/guardianset/current\x12\xcc\x01\n#GovernorGetAva\
    ilableNotionalByChain\x128.publicrpc.v1.GovernorGetAvailableNotionalByCh\
    ainRequest\x1a9.publicrpc.v1.GovernorGetAvailableNotionalByChainResponse\
    \"0\x82\xd3\xe4\x93\x02*\x12(/v1/governor/available_notional_by_chain\
    \x12\x9a\x01\n\x17GovernorGetEnqueuedVAAs\x12,.publicrpc.v1.GovernorGetE\
    nqueuedVAAsRequest\x1a-.publicrpc.v1.GovernorGetEnqueuedVAAsResponse\"\"\
    \x82\xd3\xe4\x93\x02\x1c\x12\x1a/v1/governor/enqueued_vaas\x12\xe4\x01\n\
    \x15GovernorIsVAAEnqueued\x12*.publicrpc.v1.GovernorIsVAAEnqueuedRequest\
    \x1a+.publicrpc.v1.GovernorIsVAAEnqueuedResponse\"r\x82\xd3\xe4\x93\x02l\
    \x12j/v1/governor/is_vaa_enqueued/{message_id.emitter_chain}/{message_id\
    .emitter_address}/{message_id.sequence}\x12\x8e\x01\n\x14GovernorGetToke\
    nList\x12).publicrpc.v1.GovernorGetTokenListRequest\x1a*.publicrpc.v1.Go\
    vernorGetTokenListResponse\"\x1f\x82\xd3\xe4\x93\x02\x19\x12\x17/v1/gove\
    rnor/token_listBGZEgithub.com/certusone/wormhole/node/pkg/proto/publicrp\
    c/v1;publicrpcv1b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::gossip::file_descriptor().clone());
            deps.push(super::annotations::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(23);
            messages.push(MessageID::generated_message_descriptor_data());
            messages.push(BatchID::generated_message_descriptor_data());
            messages.push(GetSignedVAARequest::generated_message_descriptor_data());
            messages.push(GetSignedVAAResponse::generated_message_descriptor_data());
            messages.push(GetSignedBatchVAARequest::generated_message_descriptor_data());
            messages.push(GetSignedBatchVAAResponse::generated_message_descriptor_data());
            messages.push(GetLastHeartbeatsRequest::generated_message_descriptor_data());
            messages.push(GetLastHeartbeatsResponse::generated_message_descriptor_data());
            messages.push(GetCurrentGuardianSetRequest::generated_message_descriptor_data());
            messages.push(GetCurrentGuardianSetResponse::generated_message_descriptor_data());
            messages.push(GuardianSet::generated_message_descriptor_data());
            messages.push(GovernorGetAvailableNotionalByChainRequest::generated_message_descriptor_data());
            messages.push(GovernorGetAvailableNotionalByChainResponse::generated_message_descriptor_data());
            messages.push(GovernorGetEnqueuedVAAsRequest::generated_message_descriptor_data());
            messages.push(GovernorGetEnqueuedVAAsResponse::generated_message_descriptor_data());
            messages.push(GovernorIsVAAEnqueuedRequest::generated_message_descriptor_data());
            messages.push(GovernorIsVAAEnqueuedResponse::generated_message_descriptor_data());
            messages.push(GovernorGetTokenListRequest::generated_message_descriptor_data());
            messages.push(GovernorGetTokenListResponse::generated_message_descriptor_data());
            messages.push(get_last_heartbeats_response::Entry::generated_message_descriptor_data());
            messages.push(governor_get_available_notional_by_chain_response::Entry::generated_message_descriptor_data());
            messages.push(governor_get_enqueued_vaas_response::Entry::generated_message_descriptor_data());
            messages.push(governor_get_token_list_response::Entry::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(ChainID::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
