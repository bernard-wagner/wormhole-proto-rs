// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.21.12
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `spy/v1/spy.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:spy.v1.EmitterFilter)
pub struct EmitterFilter {
    // message fields
    // @@protoc_insertion_point(field:spy.v1.EmitterFilter.chain_id)
    pub chain_id: ::protobuf::EnumOrUnknown<super::publicrpc::ChainID>,
    // @@protoc_insertion_point(field:spy.v1.EmitterFilter.emitter_address)
    pub emitter_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spy.v1.EmitterFilter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EmitterFilter {
    fn default() -> &'a EmitterFilter {
        <EmitterFilter as ::protobuf::Message>::default_instance()
    }
}

impl EmitterFilter {
    pub fn new() -> EmitterFilter {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chain_id",
            |m: &EmitterFilter| { &m.chain_id },
            |m: &mut EmitterFilter| { &mut m.chain_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "emitter_address",
            |m: &EmitterFilter| { &m.emitter_address },
            |m: &mut EmitterFilter| { &mut m.emitter_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EmitterFilter>(
            "EmitterFilter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EmitterFilter {
    const NAME: &'static str = "EmitterFilter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chain_id = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.emitter_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.chain_id != ::protobuf::EnumOrUnknown::new(super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.chain_id.value());
        }
        if !self.emitter_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.emitter_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.chain_id != ::protobuf::EnumOrUnknown::new(super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.chain_id))?;
        }
        if !self.emitter_address.is_empty() {
            os.write_string(2, &self.emitter_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EmitterFilter {
        EmitterFilter::new()
    }

    fn clear(&mut self) {
        self.chain_id = ::protobuf::EnumOrUnknown::new(super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED);
        self.emitter_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EmitterFilter {
        static instance: EmitterFilter = EmitterFilter {
            chain_id: ::protobuf::EnumOrUnknown::from_i32(0),
            emitter_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EmitterFilter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EmitterFilter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EmitterFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmitterFilter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:spy.v1.BatchFilter)
pub struct BatchFilter {
    // message fields
    // @@protoc_insertion_point(field:spy.v1.BatchFilter.chain_id)
    pub chain_id: ::protobuf::EnumOrUnknown<super::publicrpc::ChainID>,
    // @@protoc_insertion_point(field:spy.v1.BatchFilter.tx_id)
    pub tx_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:spy.v1.BatchFilter.nonce)
    pub nonce: u32,
    // special fields
    // @@protoc_insertion_point(special_field:spy.v1.BatchFilter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BatchFilter {
    fn default() -> &'a BatchFilter {
        <BatchFilter as ::protobuf::Message>::default_instance()
    }
}

impl BatchFilter {
    pub fn new() -> BatchFilter {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chain_id",
            |m: &BatchFilter| { &m.chain_id },
            |m: &mut BatchFilter| { &mut m.chain_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tx_id",
            |m: &BatchFilter| { &m.tx_id },
            |m: &mut BatchFilter| { &mut m.tx_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nonce",
            |m: &BatchFilter| { &m.nonce },
            |m: &mut BatchFilter| { &mut m.nonce },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BatchFilter>(
            "BatchFilter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BatchFilter {
    const NAME: &'static str = "BatchFilter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chain_id = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.tx_id = is.read_bytes()?;
                },
                24 => {
                    self.nonce = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.chain_id != ::protobuf::EnumOrUnknown::new(super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.chain_id.value());
        }
        if !self.tx_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.tx_id);
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.nonce);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.chain_id != ::protobuf::EnumOrUnknown::new(super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.chain_id))?;
        }
        if !self.tx_id.is_empty() {
            os.write_bytes(2, &self.tx_id)?;
        }
        if self.nonce != 0 {
            os.write_uint32(3, self.nonce)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BatchFilter {
        BatchFilter::new()
    }

    fn clear(&mut self) {
        self.chain_id = ::protobuf::EnumOrUnknown::new(super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED);
        self.tx_id.clear();
        self.nonce = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BatchFilter {
        static instance: BatchFilter = BatchFilter {
            chain_id: ::protobuf::EnumOrUnknown::from_i32(0),
            tx_id: ::std::vec::Vec::new(),
            nonce: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BatchFilter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BatchFilter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BatchFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchFilter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:spy.v1.BatchTransactionFilter)
pub struct BatchTransactionFilter {
    // message fields
    // @@protoc_insertion_point(field:spy.v1.BatchTransactionFilter.chain_id)
    pub chain_id: ::protobuf::EnumOrUnknown<super::publicrpc::ChainID>,
    // @@protoc_insertion_point(field:spy.v1.BatchTransactionFilter.tx_id)
    pub tx_id: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:spy.v1.BatchTransactionFilter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BatchTransactionFilter {
    fn default() -> &'a BatchTransactionFilter {
        <BatchTransactionFilter as ::protobuf::Message>::default_instance()
    }
}

impl BatchTransactionFilter {
    pub fn new() -> BatchTransactionFilter {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chain_id",
            |m: &BatchTransactionFilter| { &m.chain_id },
            |m: &mut BatchTransactionFilter| { &mut m.chain_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tx_id",
            |m: &BatchTransactionFilter| { &m.tx_id },
            |m: &mut BatchTransactionFilter| { &mut m.tx_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BatchTransactionFilter>(
            "BatchTransactionFilter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BatchTransactionFilter {
    const NAME: &'static str = "BatchTransactionFilter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chain_id = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.tx_id = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.chain_id != ::protobuf::EnumOrUnknown::new(super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.chain_id.value());
        }
        if !self.tx_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.tx_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.chain_id != ::protobuf::EnumOrUnknown::new(super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.chain_id))?;
        }
        if !self.tx_id.is_empty() {
            os.write_bytes(2, &self.tx_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BatchTransactionFilter {
        BatchTransactionFilter::new()
    }

    fn clear(&mut self) {
        self.chain_id = ::protobuf::EnumOrUnknown::new(super::publicrpc::ChainID::CHAIN_ID_UNSPECIFIED);
        self.tx_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BatchTransactionFilter {
        static instance: BatchTransactionFilter = BatchTransactionFilter {
            chain_id: ::protobuf::EnumOrUnknown::from_i32(0),
            tx_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BatchTransactionFilter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BatchTransactionFilter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BatchTransactionFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchTransactionFilter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:spy.v1.FilterEntry)
pub struct FilterEntry {
    // message oneof groups
    pub filter: ::std::option::Option<filter_entry::Filter>,
    // special fields
    // @@protoc_insertion_point(special_field:spy.v1.FilterEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FilterEntry {
    fn default() -> &'a FilterEntry {
        <FilterEntry as ::protobuf::Message>::default_instance()
    }
}

impl FilterEntry {
    pub fn new() -> FilterEntry {
        ::std::default::Default::default()
    }

    // .spy.v1.EmitterFilter emitter_filter = 1;

    pub fn emitter_filter(&self) -> &EmitterFilter {
        match self.filter {
            ::std::option::Option::Some(filter_entry::Filter::EmitterFilter(ref v)) => v,
            _ => <EmitterFilter as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_emitter_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_emitter_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(filter_entry::Filter::EmitterFilter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_emitter_filter(&mut self, v: EmitterFilter) {
        self.filter = ::std::option::Option::Some(filter_entry::Filter::EmitterFilter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_emitter_filter(&mut self) -> &mut EmitterFilter {
        if let ::std::option::Option::Some(filter_entry::Filter::EmitterFilter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(filter_entry::Filter::EmitterFilter(EmitterFilter::new()));
        }
        match self.filter {
            ::std::option::Option::Some(filter_entry::Filter::EmitterFilter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_emitter_filter(&mut self) -> EmitterFilter {
        if self.has_emitter_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(filter_entry::Filter::EmitterFilter(v)) => v,
                _ => panic!(),
            }
        } else {
            EmitterFilter::new()
        }
    }

    // .spy.v1.BatchFilter batch_filter = 2;

    pub fn batch_filter(&self) -> &BatchFilter {
        match self.filter {
            ::std::option::Option::Some(filter_entry::Filter::BatchFilter(ref v)) => v,
            _ => <BatchFilter as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_batch_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_batch_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(filter_entry::Filter::BatchFilter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_batch_filter(&mut self, v: BatchFilter) {
        self.filter = ::std::option::Option::Some(filter_entry::Filter::BatchFilter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_batch_filter(&mut self) -> &mut BatchFilter {
        if let ::std::option::Option::Some(filter_entry::Filter::BatchFilter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(filter_entry::Filter::BatchFilter(BatchFilter::new()));
        }
        match self.filter {
            ::std::option::Option::Some(filter_entry::Filter::BatchFilter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_batch_filter(&mut self) -> BatchFilter {
        if self.has_batch_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(filter_entry::Filter::BatchFilter(v)) => v,
                _ => panic!(),
            }
        } else {
            BatchFilter::new()
        }
    }

    // .spy.v1.BatchTransactionFilter batch_transaction_filter = 3;

    pub fn batch_transaction_filter(&self) -> &BatchTransactionFilter {
        match self.filter {
            ::std::option::Option::Some(filter_entry::Filter::BatchTransactionFilter(ref v)) => v,
            _ => <BatchTransactionFilter as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_batch_transaction_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_batch_transaction_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(filter_entry::Filter::BatchTransactionFilter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_batch_transaction_filter(&mut self, v: BatchTransactionFilter) {
        self.filter = ::std::option::Option::Some(filter_entry::Filter::BatchTransactionFilter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_batch_transaction_filter(&mut self) -> &mut BatchTransactionFilter {
        if let ::std::option::Option::Some(filter_entry::Filter::BatchTransactionFilter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(filter_entry::Filter::BatchTransactionFilter(BatchTransactionFilter::new()));
        }
        match self.filter {
            ::std::option::Option::Some(filter_entry::Filter::BatchTransactionFilter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_batch_transaction_filter(&mut self) -> BatchTransactionFilter {
        if self.has_batch_transaction_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(filter_entry::Filter::BatchTransactionFilter(v)) => v,
                _ => panic!(),
            }
        } else {
            BatchTransactionFilter::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, EmitterFilter>(
            "emitter_filter",
            FilterEntry::has_emitter_filter,
            FilterEntry::emitter_filter,
            FilterEntry::mut_emitter_filter,
            FilterEntry::set_emitter_filter,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BatchFilter>(
            "batch_filter",
            FilterEntry::has_batch_filter,
            FilterEntry::batch_filter,
            FilterEntry::mut_batch_filter,
            FilterEntry::set_batch_filter,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BatchTransactionFilter>(
            "batch_transaction_filter",
            FilterEntry::has_batch_transaction_filter,
            FilterEntry::batch_transaction_filter,
            FilterEntry::mut_batch_transaction_filter,
            FilterEntry::set_batch_transaction_filter,
        ));
        oneofs.push(filter_entry::Filter::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FilterEntry>(
            "FilterEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FilterEntry {
    const NAME: &'static str = "FilterEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filter = ::std::option::Option::Some(filter_entry::Filter::EmitterFilter(is.read_message()?));
                },
                18 => {
                    self.filter = ::std::option::Option::Some(filter_entry::Filter::BatchFilter(is.read_message()?));
                },
                26 => {
                    self.filter = ::std::option::Option::Some(filter_entry::Filter::BatchTransactionFilter(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &filter_entry::Filter::EmitterFilter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &filter_entry::Filter::BatchFilter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &filter_entry::Filter::BatchTransactionFilter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &filter_entry::Filter::EmitterFilter(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &filter_entry::Filter::BatchFilter(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &filter_entry::Filter::BatchTransactionFilter(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FilterEntry {
        FilterEntry::new()
    }

    fn clear(&mut self) {
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FilterEntry {
        static instance: FilterEntry = FilterEntry {
            filter: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FilterEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FilterEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FilterEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilterEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FilterEntry`
pub mod filter_entry {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:spy.v1.FilterEntry.filter)
    pub enum Filter {
        // @@protoc_insertion_point(oneof_field:spy.v1.FilterEntry.emitter_filter)
        EmitterFilter(super::EmitterFilter),
        // @@protoc_insertion_point(oneof_field:spy.v1.FilterEntry.batch_filter)
        BatchFilter(super::BatchFilter),
        // @@protoc_insertion_point(oneof_field:spy.v1.FilterEntry.batch_transaction_filter)
        BatchTransactionFilter(super::BatchTransactionFilter),
    }

    impl ::protobuf::Oneof for Filter {
    }

    impl ::protobuf::OneofFull for Filter {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::FilterEntry as ::protobuf::MessageFull>::descriptor().oneof_by_name("filter").unwrap()).clone()
        }
    }

    impl Filter {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Filter>("filter")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:spy.v1.SubscribeSignedVAARequest)
pub struct SubscribeSignedVAARequest {
    // message fields
    // @@protoc_insertion_point(field:spy.v1.SubscribeSignedVAARequest.filters)
    pub filters: ::std::vec::Vec<FilterEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:spy.v1.SubscribeSignedVAARequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeSignedVAARequest {
    fn default() -> &'a SubscribeSignedVAARequest {
        <SubscribeSignedVAARequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeSignedVAARequest {
    pub fn new() -> SubscribeSignedVAARequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "filters",
            |m: &SubscribeSignedVAARequest| { &m.filters },
            |m: &mut SubscribeSignedVAARequest| { &mut m.filters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeSignedVAARequest>(
            "SubscribeSignedVAARequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeSignedVAARequest {
    const NAME: &'static str = "SubscribeSignedVAARequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filters.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.filters {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeSignedVAARequest {
        SubscribeSignedVAARequest::new()
    }

    fn clear(&mut self) {
        self.filters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeSignedVAARequest {
        static instance: SubscribeSignedVAARequest = SubscribeSignedVAARequest {
            filters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeSignedVAARequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeSignedVAARequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeSignedVAARequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeSignedVAARequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:spy.v1.SubscribeSignedVAAByTypeRequest)
pub struct SubscribeSignedVAAByTypeRequest {
    // message fields
    // @@protoc_insertion_point(field:spy.v1.SubscribeSignedVAAByTypeRequest.filters)
    pub filters: ::std::vec::Vec<FilterEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:spy.v1.SubscribeSignedVAAByTypeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeSignedVAAByTypeRequest {
    fn default() -> &'a SubscribeSignedVAAByTypeRequest {
        <SubscribeSignedVAAByTypeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeSignedVAAByTypeRequest {
    pub fn new() -> SubscribeSignedVAAByTypeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "filters",
            |m: &SubscribeSignedVAAByTypeRequest| { &m.filters },
            |m: &mut SubscribeSignedVAAByTypeRequest| { &mut m.filters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeSignedVAAByTypeRequest>(
            "SubscribeSignedVAAByTypeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeSignedVAAByTypeRequest {
    const NAME: &'static str = "SubscribeSignedVAAByTypeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filters.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.filters {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeSignedVAAByTypeRequest {
        SubscribeSignedVAAByTypeRequest::new()
    }

    fn clear(&mut self) {
        self.filters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeSignedVAAByTypeRequest {
        static instance: SubscribeSignedVAAByTypeRequest = SubscribeSignedVAAByTypeRequest {
            filters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeSignedVAAByTypeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeSignedVAAByTypeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeSignedVAAByTypeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeSignedVAAByTypeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:spy.v1.SubscribeSignedVAAResponse)
pub struct SubscribeSignedVAAResponse {
    // message fields
    // @@protoc_insertion_point(field:spy.v1.SubscribeSignedVAAResponse.vaa_bytes)
    pub vaa_bytes: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:spy.v1.SubscribeSignedVAAResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeSignedVAAResponse {
    fn default() -> &'a SubscribeSignedVAAResponse {
        <SubscribeSignedVAAResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeSignedVAAResponse {
    pub fn new() -> SubscribeSignedVAAResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vaa_bytes",
            |m: &SubscribeSignedVAAResponse| { &m.vaa_bytes },
            |m: &mut SubscribeSignedVAAResponse| { &mut m.vaa_bytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeSignedVAAResponse>(
            "SubscribeSignedVAAResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeSignedVAAResponse {
    const NAME: &'static str = "SubscribeSignedVAAResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.vaa_bytes = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.vaa_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.vaa_bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.vaa_bytes.is_empty() {
            os.write_bytes(1, &self.vaa_bytes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeSignedVAAResponse {
        SubscribeSignedVAAResponse::new()
    }

    fn clear(&mut self) {
        self.vaa_bytes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeSignedVAAResponse {
        static instance: SubscribeSignedVAAResponse = SubscribeSignedVAAResponse {
            vaa_bytes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeSignedVAAResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeSignedVAAResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeSignedVAAResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeSignedVAAResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:spy.v1.SubscribeSignedVAAByTypeResponse)
pub struct SubscribeSignedVAAByTypeResponse {
    // message oneof groups
    pub vaa_type: ::std::option::Option<subscribe_signed_vaaby_type_response::Vaa_type>,
    // special fields
    // @@protoc_insertion_point(special_field:spy.v1.SubscribeSignedVAAByTypeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeSignedVAAByTypeResponse {
    fn default() -> &'a SubscribeSignedVAAByTypeResponse {
        <SubscribeSignedVAAByTypeResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeSignedVAAByTypeResponse {
    pub fn new() -> SubscribeSignedVAAByTypeResponse {
        ::std::default::Default::default()
    }

    // .gossip.v1.SignedVAAWithQuorum signed_vaa = 1;

    pub fn signed_vaa(&self) -> &super::gossip::SignedVAAWithQuorum {
        match self.vaa_type {
            ::std::option::Option::Some(subscribe_signed_vaaby_type_response::Vaa_type::SignedVaa(ref v)) => v,
            _ => <super::gossip::SignedVAAWithQuorum as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_signed_vaa(&mut self) {
        self.vaa_type = ::std::option::Option::None;
    }

    pub fn has_signed_vaa(&self) -> bool {
        match self.vaa_type {
            ::std::option::Option::Some(subscribe_signed_vaaby_type_response::Vaa_type::SignedVaa(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_vaa(&mut self, v: super::gossip::SignedVAAWithQuorum) {
        self.vaa_type = ::std::option::Option::Some(subscribe_signed_vaaby_type_response::Vaa_type::SignedVaa(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_vaa(&mut self) -> &mut super::gossip::SignedVAAWithQuorum {
        if let ::std::option::Option::Some(subscribe_signed_vaaby_type_response::Vaa_type::SignedVaa(_)) = self.vaa_type {
        } else {
            self.vaa_type = ::std::option::Option::Some(subscribe_signed_vaaby_type_response::Vaa_type::SignedVaa(super::gossip::SignedVAAWithQuorum::new()));
        }
        match self.vaa_type {
            ::std::option::Option::Some(subscribe_signed_vaaby_type_response::Vaa_type::SignedVaa(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_vaa(&mut self) -> super::gossip::SignedVAAWithQuorum {
        if self.has_signed_vaa() {
            match self.vaa_type.take() {
                ::std::option::Option::Some(subscribe_signed_vaaby_type_response::Vaa_type::SignedVaa(v)) => v,
                _ => panic!(),
            }
        } else {
            super::gossip::SignedVAAWithQuorum::new()
        }
    }

    // .gossip.v1.SignedBatchVAAWithQuorum signed_batch_vaa = 2;

    pub fn signed_batch_vaa(&self) -> &super::gossip::SignedBatchVAAWithQuorum {
        match self.vaa_type {
            ::std::option::Option::Some(subscribe_signed_vaaby_type_response::Vaa_type::SignedBatchVaa(ref v)) => v,
            _ => <super::gossip::SignedBatchVAAWithQuorum as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_signed_batch_vaa(&mut self) {
        self.vaa_type = ::std::option::Option::None;
    }

    pub fn has_signed_batch_vaa(&self) -> bool {
        match self.vaa_type {
            ::std::option::Option::Some(subscribe_signed_vaaby_type_response::Vaa_type::SignedBatchVaa(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_batch_vaa(&mut self, v: super::gossip::SignedBatchVAAWithQuorum) {
        self.vaa_type = ::std::option::Option::Some(subscribe_signed_vaaby_type_response::Vaa_type::SignedBatchVaa(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_batch_vaa(&mut self) -> &mut super::gossip::SignedBatchVAAWithQuorum {
        if let ::std::option::Option::Some(subscribe_signed_vaaby_type_response::Vaa_type::SignedBatchVaa(_)) = self.vaa_type {
        } else {
            self.vaa_type = ::std::option::Option::Some(subscribe_signed_vaaby_type_response::Vaa_type::SignedBatchVaa(super::gossip::SignedBatchVAAWithQuorum::new()));
        }
        match self.vaa_type {
            ::std::option::Option::Some(subscribe_signed_vaaby_type_response::Vaa_type::SignedBatchVaa(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_batch_vaa(&mut self) -> super::gossip::SignedBatchVAAWithQuorum {
        if self.has_signed_batch_vaa() {
            match self.vaa_type.take() {
                ::std::option::Option::Some(subscribe_signed_vaaby_type_response::Vaa_type::SignedBatchVaa(v)) => v,
                _ => panic!(),
            }
        } else {
            super::gossip::SignedBatchVAAWithQuorum::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::gossip::SignedVAAWithQuorum>(
            "signed_vaa",
            SubscribeSignedVAAByTypeResponse::has_signed_vaa,
            SubscribeSignedVAAByTypeResponse::signed_vaa,
            SubscribeSignedVAAByTypeResponse::mut_signed_vaa,
            SubscribeSignedVAAByTypeResponse::set_signed_vaa,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::gossip::SignedBatchVAAWithQuorum>(
            "signed_batch_vaa",
            SubscribeSignedVAAByTypeResponse::has_signed_batch_vaa,
            SubscribeSignedVAAByTypeResponse::signed_batch_vaa,
            SubscribeSignedVAAByTypeResponse::mut_signed_batch_vaa,
            SubscribeSignedVAAByTypeResponse::set_signed_batch_vaa,
        ));
        oneofs.push(subscribe_signed_vaaby_type_response::Vaa_type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeSignedVAAByTypeResponse>(
            "SubscribeSignedVAAByTypeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeSignedVAAByTypeResponse {
    const NAME: &'static str = "SubscribeSignedVAAByTypeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.vaa_type = ::std::option::Option::Some(subscribe_signed_vaaby_type_response::Vaa_type::SignedVaa(is.read_message()?));
                },
                18 => {
                    self.vaa_type = ::std::option::Option::Some(subscribe_signed_vaaby_type_response::Vaa_type::SignedBatchVaa(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.vaa_type {
            match v {
                &subscribe_signed_vaaby_type_response::Vaa_type::SignedVaa(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &subscribe_signed_vaaby_type_response::Vaa_type::SignedBatchVaa(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.vaa_type {
            match v {
                &subscribe_signed_vaaby_type_response::Vaa_type::SignedVaa(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &subscribe_signed_vaaby_type_response::Vaa_type::SignedBatchVaa(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeSignedVAAByTypeResponse {
        SubscribeSignedVAAByTypeResponse::new()
    }

    fn clear(&mut self) {
        self.vaa_type = ::std::option::Option::None;
        self.vaa_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeSignedVAAByTypeResponse {
        static instance: SubscribeSignedVAAByTypeResponse = SubscribeSignedVAAByTypeResponse {
            vaa_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeSignedVAAByTypeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeSignedVAAByTypeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeSignedVAAByTypeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeSignedVAAByTypeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SubscribeSignedVAAByTypeResponse`
pub mod subscribe_signed_vaaby_type_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:spy.v1.SubscribeSignedVAAByTypeResponse.vaa_type)
    pub enum Vaa_type {
        // @@protoc_insertion_point(oneof_field:spy.v1.SubscribeSignedVAAByTypeResponse.signed_vaa)
        SignedVaa(super::super::gossip::SignedVAAWithQuorum),
        // @@protoc_insertion_point(oneof_field:spy.v1.SubscribeSignedVAAByTypeResponse.signed_batch_vaa)
        SignedBatchVaa(super::super::gossip::SignedBatchVAAWithQuorum),
    }

    impl ::protobuf::Oneof for Vaa_type {
    }

    impl ::protobuf::OneofFull for Vaa_type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::SubscribeSignedVAAByTypeResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("vaa_type").unwrap()).clone()
        }
    }

    impl Vaa_type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Vaa_type>("vaa_type")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10spy/v1/spy.proto\x12\x06spy.v1\x1a\x1cgoogle/api/annotations.proto\
    \x1a\x16gossip/v1/gossip.proto\x1a\x1cpublicrpc/v1/publicrpc.proto\"j\n\
    \rEmitterFilter\x120\n\x08chain_id\x18\x01\x20\x01(\x0e2\x15.publicrpc.v\
    1.ChainIDR\x07chainId\x12'\n\x0femitter_address\x18\x02\x20\x01(\tR\x0ee\
    mitterAddress\"j\n\x0bBatchFilter\x120\n\x08chain_id\x18\x01\x20\x01(\
    \x0e2\x15.publicrpc.v1.ChainIDR\x07chainId\x12\x13\n\x05tx_id\x18\x02\
    \x20\x01(\x0cR\x04txId\x12\x14\n\x05nonce\x18\x03\x20\x01(\rR\x05nonce\"\
    _\n\x16BatchTransactionFilter\x120\n\x08chain_id\x18\x01\x20\x01(\x0e2\
    \x15.publicrpc.v1.ChainIDR\x07chainId\x12\x13\n\x05tx_id\x18\x02\x20\x01\
    (\x0cR\x04txId\"\xed\x01\n\x0bFilterEntry\x12>\n\x0eemitter_filter\x18\
    \x01\x20\x01(\x0b2\x15.spy.v1.EmitterFilterH\0R\remitterFilter\x128\n\
    \x0cbatch_filter\x18\x02\x20\x01(\x0b2\x13.spy.v1.BatchFilterH\0R\x0bbat\
    chFilter\x12Z\n\x18batch_transaction_filter\x18\x03\x20\x01(\x0b2\x1e.sp\
    y.v1.BatchTransactionFilterH\0R\x16batchTransactionFilterB\x08\n\x06filt\
    er\"J\n\x19SubscribeSignedVAARequest\x12-\n\x07filters\x18\x01\x20\x03(\
    \x0b2\x13.spy.v1.FilterEntryR\x07filters\"P\n\x1fSubscribeSignedVAAByTyp\
    eRequest\x12-\n\x07filters\x18\x01\x20\x03(\x0b2\x13.spy.v1.FilterEntryR\
    \x07filters\"9\n\x1aSubscribeSignedVAAResponse\x12\x1b\n\tvaa_bytes\x18\
    \x01\x20\x01(\x0cR\x08vaaBytes\"\xc0\x01\n\x20SubscribeSignedVAAByTypeRe\
    sponse\x12?\n\nsigned_vaa\x18\x01\x20\x01(\x0b2\x1e.gossip.v1.SignedVAAW\
    ithQuorumH\0R\tsignedVaa\x12O\n\x10signed_batch_vaa\x18\x02\x20\x01(\x0b\
    2#.gossip.v1.SignedBatchVAAWithQuorumH\0R\x0esignedBatchVaaB\n\n\x08vaa_\
    type2\xb3\x02\n\rSpyRPCService\x12\x82\x01\n\x12SubscribeSignedVAA\x12!.\
    spy.v1.SubscribeSignedVAARequest\x1a\".spy.v1.SubscribeSignedVAAResponse\
    \"#\x82\xd3\xe4\x93\x02\x1d\"\x18/v1:subscribe_signed_vaa:\x01*0\x01\x12\
    \x9c\x01\n\x18SubscribeSignedVAAByType\x12'.spy.v1.SubscribeSignedVAAByT\
    ypeRequest\x1a(.spy.v1.SubscribeSignedVAAByTypeResponse\"+\x82\xd3\xe4\
    \x93\x02%\"\x20/v1:subscribe_signed_vaa_by_type:\x01*0\x01B;Z9github.com\
    /certusone/wormhole/node/pkg/proto/spy/v1;spyv1b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(super::gossip::file_descriptor().clone());
            deps.push(super::publicrpc::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(8);
            messages.push(EmitterFilter::generated_message_descriptor_data());
            messages.push(BatchFilter::generated_message_descriptor_data());
            messages.push(BatchTransactionFilter::generated_message_descriptor_data());
            messages.push(FilterEntry::generated_message_descriptor_data());
            messages.push(SubscribeSignedVAARequest::generated_message_descriptor_data());
            messages.push(SubscribeSignedVAAByTypeRequest::generated_message_descriptor_data());
            messages.push(SubscribeSignedVAAResponse::generated_message_descriptor_data());
            messages.push(SubscribeSignedVAAByTypeResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
